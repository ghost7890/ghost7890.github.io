[{"title":"深入理解协程（四）：async/await异步爬虫实战","date":"2020-01-17T02:38:05.000Z","path":"2020/01/17/coroutine4/","text":"本文目录： 同步方式爬取博客标题 async/await异步爬取博客标题 本片为深入理解协程系列文章的补充。你将会在从本文中了解到：async/await如何运用的实际的爬虫中。 案例从CSDN上批量爬取指定文章的标题。文章列表如下： 123456789101112131415urls = [ 'https://blog.csdn.net/Jmilk/article/details/103218919', 'https://blog.csdn.net/stven_king/article/details/103256724', 'https://blog.csdn.net/csdnnews/article/details/103154693', 'https://blog.csdn.net/dg_lee/article/details/103951021', 'https://blog.csdn.net/m0_37907797/article/details/103272967', 'https://blog.csdn.net/zzq900503/article/details/49618605', 'https://blog.csdn.net/weixin_44339238/article/details/103977138', 'https://blog.csdn.net/dengjin20104042056/article/details/103930275', 'https://blog.csdn.net/Mind_programmonkey/article/details/103940511', 'https://blog.csdn.net/xufive/article/details/102993570', 'https://blog.csdn.net/weixin_41010294/article/details/104009722', 'https://blog.csdn.net/yunqiinsight/article/details/103137022', 'https://blog.csdn.net/qq_44210563/article/details/102826406',] 同步爬虫123456789101112131415161718192021222324252627import requestsimport timefrom lxml import etreeurls = [ 'https://blog.csdn.net/Jmilk/article/details/103218919', 'https://blog.csdn.net/stven_king/article/details/103256724', ...此处略]def get_title(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36' &#125; r = requests.get(url, headers) html = r.content title = etree.HTML(html).xpath('//h1[@class=\"title-article\"]/text()')[0] print(title) def main(): for url in urls: get_title(url) if __name__ == '__main__': start = time.time() main() print(f'cost time: &#123;time.time() - start&#125;s') 输出结果如下： 12345678910111213144G LTE/EPC 协议栈Android-Universal-Image-Loader源码分析8年经验面试官详解 Java 面试秘诀AES中ECB模式的加密与解密（Python3.7）【图解算法面试】记一次面试：说说游戏中的敏感词过滤是如何实现的？java进阶(四)------java编程规范---代码质量检测工具FindBugs、PMD和CheckStyle的安装这是一份集合一线大厂Android工程师必备技能体系+学习路线！【程序人生】程序员接私活常用平台汇总你不得不了解的卷积神经网络发展史致 Python 初学者OOM别慌，手把手教你定位中国数据库OceanBase登顶之路网页实现一个简单的音乐播放器（大佬别看。(⊙﹏⊙)）cost time: 6.065227508544922s 用时：6.065227508544922s。 async/await异步爬虫要实现一个真正的异步爬虫，就需要引入aiohttp模块，aiohttp是一个利用asyncio的库，可以暂时看成协程版的requests。 12345678910111213141516171819202122232425262728293031import asyncioimport timeimport aiohttpfrom lxml import etreeurls = [ 'https://blog.csdn.net/Jmilk/article/details/103218919', 'https://blog.csdn.net/stven_king/article/details/103256724', ...此处略]async def async_get_url(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36' &#125; async with aiohttp.ClientSession() as session: # 解释1 async with session.get(url, headers=headers) as r: html = await r.read() title = etree.HTML(html).xpath('//h1[@class=\"title-article\"]/text()')[0] print(title) def async_main(): loop = asyncio.get_event_loop() tasks = [async_get_url(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == '__main__': start = time.time() async_main() print(f'cost time: &#123;time.time() - start&#125;s') 输出结果： 1234567891011121314网页实现一个简单的音乐播放器（大佬别看。(⊙﹏⊙)）【程序人生】程序员接私活常用平台汇总致 Python 初学者中国数据库OceanBase登顶之路Android-Universal-Image-Loader源码分析OOM别慌，手把手教你定位这是一份集合一线大厂Android工程师必备技能体系+学习路线！AES中ECB模式的加密与解密（Python3.7）4G LTE/EPC 协议栈【图解算法面试】记一次面试：说说游戏中的敏感词过滤是如何实现的？8年经验面试官详解 Java 面试秘诀java进阶(四)------java编程规范---代码质量检测工具FindBugs、PMD和CheckStyle的安装你不得不了解的卷积神经网络发展史cost time: 0.6428999900817871s 说明： 解释1：此处为异步的上下文管理器，是aiohttp官方文档提供的写法。如果对上下文管理器不是很了解的话，可以参看【Python进阶：上下文管理器】。 用时：0.6428999900817871s。从两种爬虫的输出结果中可以看到： 文章标题的顺序不同。同步爬虫会按照urls内部的url顺序依次爬取文章标题。而异步爬虫爬取的顺序并不完全和urls中的url顺序相同。 速度大概是普通同步爬虫的8~10倍。异步爬虫充分利用了网络请求这段时间。从而提高了爬取效率。 关于aiohttp的更多用法。会在后面文章讲到。 推荐阅读深入理解协程（一）：协程的引入 深入理解协程（二）：yield from实现异步协程 深入理解协程（三）：async/await实现异步协程 Python进阶：上下文管理器","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"深入理解协程（三）：async/await实现异步协程","date":"2020-01-14T12:38:05.000Z","path":"2020/01/14/coroutine3/","text":"原创不易，转载请联系作者 深入理解协程分为三部分进行讲解： 协程的引入 yield from实现异步协程 async/await实现异步协程 本篇为深入理解协程系列文章的最后一篇。 从本篇你将了解到： async/await的使用。 如何从yield from风格的协程修改为async/await风格。 篇幅较长，请耐心阅读。 async/await的引入上篇【yield from实现异步协程】我们引入了asynico模块，结合yield from实现异步协程。但语法不够简洁，其中涉及的生成器，装饰器也让人头疼不已。 为了语法更加简洁。于是，在Python3.5（PEP 492）中新增了async/await语法来实现异步协程。 async/await的使用先介绍几个概念： async/await ：python3.5之后用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。 event_loop ：事件循环，程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。 coroutine ：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。 task ：任务，是对协程进一步封装，其中包含任务的各种状态。 future： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别 1.创建协程在def前加上async的声明，就完成了一个协程函数的定义。协程函数不能直接调用运行，需要将协程注册到事件循环，并启动事件循环才能使用。 1234567891011121314import asyncioasync def fun(a): # 定义协程函数 print(a)# 调用协程函数，生成一个协程对象，此时协程函数并未执行coroutine = fun('hello world')# 创建事件循环loop = asyncio.get_event_loop()# 将协程函数添加到事件循环，并启动loop.run_until_complete(coroutine)# 输出hello word 2. 任务对象task协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象。我们也可以显式实现它。 实现方式1： 使用create_task()创建task。 1234567891011121314import asyncioasync def fun(a): print(a) return acoroutine = fun('hello world')loop = asyncio.get_event_loop()# 使用create_task()创建task，并将coroutine对象转化成task对象task = loop.create_task(coroutine)print(f'task: &#123;task&#125;')loop.run_until_complete(task)print(f'task: &#123;task&#125;')print(f'result: &#123;result&#125;') 输出结果： 123task: &lt;Task pending coro=&lt;fun() running at D:/test.py:3&gt;&gt;hello worldtask: &lt;Task finished coro=&lt;fun() done, defined at D:/test.py:3&gt; result='hello world'&gt; 从输出结果能看到，创建task对象后，未将task添加到事件循环之前，状态是pending；task对象执行完毕后，状态是finished，并将参数a的值返回。 实现方式2: 使用asyncio 的 ensure_future() 方法，创建task。 12345678910111213import asyncioasync def fun(a): print(a) return acoroutine = fun('hello world')# 使用asyncio 的 ensure_future() 方法，创建task，并将coroutine对象转化成task对象task = asyncio.ensure_future(coroutine)loop = asyncio.get_event_loop()print(f'task: &#123;task&#125;')loop.run_until_complete(task)print(f'task: &#123;task&#125;') 输出结果： 123task: &lt;Task pending coro=&lt;fun() running at D:/test.py:3&gt;&gt;hello worldtask: &lt;Task finished coro=&lt;fun() done, defined at D:/test.py:3&gt; result='hello world'&gt; 通过ensure_future() 可以在loop未定义前创建task。实现效果与上面相同。 3.绑定回调函数如果需要在task执行完毕后对结果进行处理，可以通过给task绑定回调函数完成，回调的最后一个参数是future对象（如task对象）。 12345678910111213141516import asyncioasync def fun(a): print(a) return adef callback(task): # 回调函数，打印task的返回值 print(f'result: &#123;task.result()&#125;')coroutine = fun('hello world')loop = asyncio.get_event_loop()task = loop.create_task(coroutine)task.add_done_callback(callback) #绑定回调函数print(f'task: &#123;task&#125;')loop.run_until_complete(task)print(f'task: &#123;task&#125;') 输出结果： 1234task: &lt;Task pending coro=&lt;fun() running at D:/test.py:3&gt; cb=[callback() at D:/Study/Python/python_text/非项目/协程.py:7]&gt;hello worldresult: hello world # 完成了返回值的打印task: &lt;Task finished coro=&lt;fun() done, defined at D:/test.py:3&gt; result='hello world'&gt; 4.多任务协程如果我们需要执行多个任务时，我们可以定义一个任务列表，并将需要完成的协程任务都加进去。将原本的loop.run_until_complete(tasks)改为loop.run_until_complete(asyncio.wait(tasks))。 如果执行的是多个耗时的任务，如网络请求、文件读取等。此时就await就派上用场了，await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。 举个例子： 12345678910111213141516171819202122232425262728import timeimport asyncioasync def taskIO_1(): print('开始运行IO任务1...') await asyncio.sleep(2) print('IO任务1已完成，耗时2s') return taskIO_1.__name__async def taskIO_2(): print('开始运行IO任务2...') await asyncio.sleep(3) print('IO任务2已完成，耗时3s') return taskIO_2.__name__if __name__ == '__main__': start = time.time() loop = asyncio.get_event_loop() tasks = [taskIO_1(), taskIO_2()] loop.run_until_complete(asyncio.wait(tasks)) # 完成事件循环，直到最后一个任务结束 print('所有IO任务总耗时%.5f秒' % float(time.time()-start)) # 输出开始运行IO任务2...开始运行IO任务1...IO任务1已完成，耗时2sIO任务2已完成，耗时3s所有IO任务总耗时3.00251秒 可以看出，原本需要5秒，现在执行只需要3秒。 yield from转async/await上述代码有没有很眼熟。 其实，这段代码正是【yield from实现异步协程】末尾，yield from结合asynico实现异步协程的代码。只是将yielf from风格变为async/await风格。 由于async/await与yield from风格的协程底层实现方式相同。因此，从yield from风格改为async/await风格非常容易。只需： 把`@asyncio.coroutine替换为async`； 把yield from替换为await。 async/await风格的代码隐藏了装饰器、yield from语法，方便了人们的理解，同时也让代码更加简洁。 推荐阅读深入理解协程（一）：协程的引入 深入理解协程（二）：yield from实现异步协程","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"深入理解协程（二）：yield from实现异步协程","date":"2020-01-11T12:38:05.000Z","path":"2020/01/11/coroutine2/","text":"原创不易，转载请联系作者 深入理解协程分为三部分进行讲解： 协程的引入 yield from实现异步协程 async/await实现异步协程 本篇为深入理解协程系列文章的第二篇。 yield fromyield from是Python3.3（PEP 380）引入的新语法。主要用于解决在生成器中不方便使用生成器的问题。主要有两个功能。 第一个功能：让嵌套生成器不必再通过循环迭代yield，而可以直接使用yield from。 看一段代码： 123456789101112131415161718titles = ['Python', 'Java', 'C++']def func1(titles): yield titlesdef func2(titles): yield from titlesfor title in func1(titles): print(title)for title in func2(titles): print(title) # 输出结果['Python', 'Java', 'C++']PythonJavaC++ yield返回的完整的titles列表，而yield from返回的是列表中的具体元素。yield from可以看作是for title in titles: yield title的缩写。这样就可以用yield from减少了一次循环。 第二个功能：打开双向通道，把最外层给调用方与最内层的子生成器链接起来，二者可以直接通信。 第二个功能听起来就让人头大。我们再举一个例子进行说明： 【举个例子】：通过生成器实现整数相加，通过send()函数想生成器中传入要相加的数字，最后传入None结束相加。total保存结果。 123456789101112131415161718192021222324252627def generator_1(): # 子生成器 total = 0 while True: x = yield # 解释4 print(f'+ &#123;x&#125;') if not x: break total += x return total # 解释5def generator_2(): # 委托生成器 while True: total = yield from generator_1() # 解释3 print(f'total: &#123;total&#125;')if __name__ == '__main__': # 调用方 g2 = generator_2() # 解释1 g2.send(None) # 解释2 g2.send(2) # 解释6 g2.send(3) g2.send(None) # 解释7# 输出结果+ 2+ 3+ Nonetotal: 5 说明： 解释1：g2是调用generator_2()得到的生成器对象，作为协程使用。 解释2：预激活协程g2。 解释3：generator_2接收的值都会经过yield from处理，通过管道传入generator_1实例。generator_2会在yield from处暂停，等待generator_1实例传回的值赋值给total。 解释4：调用方传入的值都会传到这里。 解释5：此处返回的total正是generator_2()中解释3处等待返回的值。 解释6：传入2进行计算。 解释7：在计算的结尾传入None，跳出generator_1()的循环，结束计算。 说到这里，相信看过《深入理解协程（一）：协程的引入》的朋友应该就容易理解上面这段代码的运行流程了。 借助上面例子，说明一下随yield from一起引入的3个概念： 子生成器 从yield from获取任务并完成具体实现的生成器。 委派生成器 包含有 yield from表达式的生成器函数。负责给子生成器委派任务。 调用方 指调用委派生成器的客户端代码。 在每次调用send(value)时，value不是传递给委派生成器，而是借助yield from将value传递给了子生成器的yield。 结合asyncio实现异步协程asyncio是Python 3.4 试验性引入的异步I/O框架（PEP 3156），提供了基于协程做异步I/O编写单线程并发代码的基础设施。其核心组件有事件循环（Event Loop）、协程(Coroutine）、任务(Task)、未来对象(Future)以及其他一些扩充和辅助性质的模块。 在引入asyncio的时候，还提供了一个装饰器`@asyncio.coroutine用于装饰使用了yield from`的函数，以标记其为协程。 在实现异步协程之前，我们先看一个同步的案例： 1234567891011121314151617181920import timedef taskIO_1(): print('开始运行IO任务1...') time.sleep(2) # 假设该任务耗时2s print('IO任务1已完成，耗时2s')def taskIO_2(): print('开始运行IO任务2...') time.sleep(3) # 假设该任务耗时3s print('IO任务2已完成，耗时3s')start = time.time()taskIO_1()taskIO_2()print('所有IO任务总耗时%.5f秒' % float(time.time()-start))# 输出结果开始运行IO任务1...IO任务1已完成，耗时2s开始运行IO任务2...IO任务2已完成，耗时3s所有IO任务总耗时5.00094秒 可以看到，使用同步的方式实现多个IO任务的时间是分别执行这两个IO任务时间的总和。 下面我们使用yield from与asyncio将上面的同步代码改成异步的。修改结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import timeimport asyncio@asyncio.coroutine # 解释1def taskIO_1(): print('开始运行IO任务1...') yield from asyncio.sleep(2) # 解释2 print('IO任务1已完成，耗时2s') return taskIO_1.__name__@asyncio.coroutine def taskIO_2(): print('开始运行IO任务2...') yield from asyncio.sleep(3) # 假设该任务耗时3s print('IO任务2已完成，耗时3s') return taskIO_2.__name__@asyncio.coroutine def main(): # 调用方 tasks = [taskIO_1(), taskIO_2()] # 把所有任务添加到task中 done,pending = yield from asyncio.wait(tasks) # 子生成器 for r in done: # done和pending都是一个任务，所以返回结果需要逐个调用result() print('协程无序返回值：'+r.result())if __name__ == '__main__': start = time.time() loop = asyncio.get_event_loop() # 创建一个事件循环对象loop try: loop.run_until_complete(main()) # 完成事件循环，直到最后一个任务结束 finally: loop.close() # 结束事件循环 print('所有IO任务总耗时%.5f秒' % float(time.time()-start)) # 输出结果开始运行IO任务2...开始运行IO任务1...IO任务1已完成，耗时2sIO任务2已完成，耗时3s协程无序返回值：taskIO_1协程无序返回值：taskIO_2所有IO任务总耗时3.00303秒 说明： 解释1：`@asyncio.coroutine**装饰器**是协程函数的标志，我们需要在每一个任务函数前加这个装饰器，并在函数中使用yield from`。 解释2：此处假设该任务运行需要2秒，此处使用异步等待2秒asyncio.sleep(2)，而非同步等待time.sleep(2)。 执行过程： 先通过get_event_loop()获取了一个标准事件循环loop(因为是一个，所以协程是单线程) 然后，我们通过run_until_complete(main())来运行协程(此处把调用方协程main()作为参数，调用方负责调用其他委托生成器)，run_until_complete的特点就像该函数的名字，直到循环事件的所有事件都处理完才能完整结束. 进入调用方协程，我们把多个任务[taskIO_1()和taskIO_2()]放到一个task列表中，可理解为打包任务。 我们使用asyncio.wait(tasks)来获取一个awaitable objects即可等待对象的集合，通过yield from返回一个包含(done, pending)的元组，done表示已完成的任务列表，pending表示未完成的任务列表。 因为done里面有我们需要的返回结果，但它目前还是个任务列表，所以要取出返回的结果值，我们遍历它并逐个调用result()取出结果即可。 最后我们通过loop.close()关闭事件循环。 可见，通过使用协程，极大提高了多任务的执行效率，程序最后消耗的时间是任务队列中耗时最多时间任务的时长。 总结本篇讲述了： yield from如何实现协程 如何结合asyncio实现异步协程 虽然有了yield from的存在，让协程实现比之前容易了，但是这种异步协程的实现方式，并不是很pythonic。现在已经不推荐使用了。下篇将与您分享更加完善的Python异步实现方式——async/await实现异步协程。 参考Python异步IO之协程(一):从yield from到async的使用","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"《大话设计模式》——代理模式（Python版）","date":"2020-01-06T13:07:43.000Z","path":"2020/01/06/designmodel4/","text":"代理模式：为其他对象提供一种代理以控制对这个对象的访问。 在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式分为： 静态代理 动态代理 由下面三部分组成： 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 静态代理在程序运行前，就已经确定代理类和委托类的关系的代理方式，被称为静态代理。 例：小明请律师进行诉讼 诉讼流程可抽象为ILawsuit类，如下： 1234567891011121314import abcclass ILawsuit(metaclass=abc.ABCMeta): @abc.abstractmethod def submit(self): # 提交申请 pass @abc.abstractmethod def burden(self): # 进行举证 pass @abc.abstractmethod def defend(self): # 开始辩护 pass @abc.abstractmethod def finish(self): # 诉讼完成 pass 小明为具体诉讼人，可写为Litigant类，如下：1234567891011class Litigant(ILawsuit): # 继承于ILawsuit def __init__(self, name): self.name = name def submit(self): print(f'&#123;self.name&#125;申请仲裁！') def burden(self): print('证据如下：XXXXXX') def defend(self): print('辩护过程：XXXXXX') def finish(self): print('诉讼结果如下：XXXXXX') 律师可写为Lawyer类，如下：1234567891011class Lawyer(ILawsuit): # 继承于ILawsuit def __init__(self, litigant): self.litigant = litigant # 具体诉讼人 def submit(self): self.litigant.submit() def burden(self): self.litigant.burden() def defend(self): self.litigant.defend() def finish(self): self.litigant.finish() 诉讼过程，可表示为：12345678910111213if __name__ == '__main__': xiaoming = Litigant('小明') lawyer = Lawyer(xiaoming) lawyer.submit() # 律师提交诉讼申请 lawyer.burden() # 律师进行举证 lawyer.defend() # 律师替小明辩护 lawyer.finish() # 完成诉讼 # 输出结果小明申请仲裁！证据如下：XXXXXX辩护过程：XXXXXX诉讼结果如下：XXXXXX 静态代理的优缺点 优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。 缺点：代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。 动态代理代理类在程序运行时创建的代理方式被称为 动态代理。 也就是说，这种情况下，代理类并不是在代码中定义的，而是在运行时根据我们在代码中的指示动态生成的。 同样，我们举例说明： 通常我们调用REST API通常可能是这样的：123456789101112import urllibimport jsondef fetch_resource(resource_id): opener = urllib.urlopen('http://remote.server/api/resource/' + resource_id) if opener.code != 200: raise RuntimeError('invalid return code!') content = opener.read() try: return json.loads(content) except ValueError: return content 对于每一个REST操作，都会有类似的代码。差别仅在于API的地址和HTTP method（GET、POST、等）。此时，可以引入一个GetProxy，可以代替我们实现这些繁杂的工作。 12345678910111213141516import urllibimport jsonclass GetProxy(object): def __getattr__(self, api_path): def _rest_fetch(*paras): opener = urllib.urlopen('http://remote.server/api/' + api_path + '/' + '/'.join(resource_id)) if opener.code != 200: raise RuntimeError('invalid return code!') content = opener.read() try: return json.loads(content) except ValueError: return content return _rest_fetch 此时，新的调用方式如下：12345proxy = GetProxy()# 调用APIproxy.user(123) # http://remote.server/api/user/123proxy.resource('switch', 456) # http://remote.server/api/resource/switch/456 可见，通过动态代理，极大简化了调用过程。 相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 参考http://adolph.cc/15712984956484.htmlhttps://blog.zhangyu.so/python/2016/02/24/design-patterns-of-python-proxy/","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mrleecn.cn/tags/设计模式/"}]},{"title":"深入理解协程（二）：yield from实现协程","date":"2019-12-16T13:37:40.000Z","path":"2019/12/16/yieldfrom/","text":"原创不易，转载请联系作者 深入理解协程分为三部分进行讲解： 协程的引入 yield from实现协程 async/await实现异步协程 本篇为深入理解协程文章的第二篇。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"深入理解协程（一）：协程的引入","date":"2019-12-14T12:20:32.000Z","path":"2019/12/14/coroutine/","text":"原创不易，转载请联系作者 深入理解协程分为三部分进行讲解： 协程的引入 yield from实现协程 async/await实现异步协程 本篇为深入理解协程文章的第一篇。 什么是协程协程：英文叫做 Coroutine，又称微线程，纤程，是一种用户态的轻量级线程。 本质上是单线程，拥有自己的寄存器上下文和栈。所以能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 与多进程相比，无需线程上下文切换的开销；与多线程相比，无需使用多线程的锁机制。执行效率要高于多进程和多线程。 最简单的协程在Python2.5时引入，是通过生成器（generator）实现的。下面来看一下生成器实现的最简单的协程。 1234567891011121314151617&gt;&gt;&gt; def coroutine(): # 注释一 print('-&gt; coroutine started') x = yield # 注释二 print('-&gt; coroutine received:', x) &gt;&gt;&gt; c = coroutine() # 注释三&gt;&gt;&gt; c &lt;generator object coroutine at 0x03899230&gt;&gt;&gt;&gt; next(c) # 注释四-&gt; coroutine started&gt;&gt;&gt; c.send(1) # 注释五-&gt; coroutine received: 1Traceback (most recent call last): File \"&lt;input&gt;\", line 1, in &lt;module&gt;StopIteration # 注释六 注释一：使用生成器函数定义一个协程（函数中需有yield关键字） 注释二：yield关键字分为左右两边理解，yield右边用于返回数据，左边用于接收用户数据。如果只从用户客户端接收数据，那么yield返回值为None。 注释三：创建生成器。 注释四：刚创建的生成器需要预激活，这里调用next()函数对生成器进行预激活。也可使用c.send(None)。 注释五：预激活完成后，使用send()函数传入数据，协程生成器中在yield处会计算出1，程序继续运行直到运行到下一个yield表达式出现或程序终止。 注释六：由于程序运行到结尾，协程生成器中再无yield关键字，导致生成器像往常一样抛出StopIteration异常。 协程的四种状态 GEN_CREATED 协程生成器创建完成，等待开始执行。 GEN_RUNNING 解释器正在执行。 GEN_SUSPENDED 在yield表达式处暂停。 GEN_CLOSED 执行结束。 协程当前的状态可通过inspect模块查询。 下面举一个产出多个值的例子，以便更好理解协程的行为。 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; from inspect import getgeneratorstate&gt;&gt;&gt; def coroutine(a): print('-&gt; started a=', a) b = yield a print('-&gt; received: b=', b) c = yield a + b print('-&gt; received: c=:', c) &gt;&gt;&gt; x = coroutine(1)&gt;&gt;&gt; getgeneratorstate(x)'GEN_CREATED' # 注释一&gt;&gt;&gt; next(x) -&gt; started a= 11 # 注释二&gt;&gt;&gt; x.send(2) -&gt; received: b= 23 # 注释三&gt;&gt;&gt; getgeneratorstate(x)'GEN_SUSPENDED' # 注释四&gt;&gt;&gt; x.send(3)Traceback (most recent call last):-&gt; received: c=: 3 File \"&lt;input&gt;\", line 1, in &lt;module&gt;StopIteration &gt;&gt;&gt; getgeneratorstate(x)'GEN_CLOSED' # 注释五 注释一：刚创建生成器，协程生成器还处于GEN_CREATED状态（协程未启动）。 注释二：使用next(x)预激活协程生成器，程序执行到第一个yield暂停，即返回a的值1。 注释三：x.send(2)向协程生成器传入值2并赋值给变量b，程序执行到第二个yield暂停，此处返回a+b的值，即为3。 注释四：此时程序在第二个yield处暂停，所以协程生成器处于GEN_SUSPENDED状态。 注释五：协程生成器抛出异常后，导致协程生成器结束，因此处于GEN_CLOSED状态。 终止协程上面举例的协程都是以抛出异常结束的，其实可以使用close()方法正常结束协程。 我们将第一示例代码进行修改， 1234567891011121314151617181920212223&gt;&gt;&gt; from inspect import getgeneratorstate&gt;&gt;&gt; def coroutine(): print('-&gt; coroutine started') while True: # 注释一 x = yield print('-&gt; coroutine received:', x) &gt;&gt;&gt; c = coroutine()&gt;&gt;&gt; next(c)-&gt; coroutine started&gt;&gt;&gt; c.send(1)-&gt; coroutine received: 1 &gt;&gt;&gt; c.send(2)-&gt; coroutine received: 2 &gt;&gt;&gt; getgeneratorstate(c)'GEN_SUSPENDED' &gt;&gt;&gt; c.close() &gt;&gt;&gt; getgeneratorstate(c)'GEN_CLOSED' # 注释二 注释一：此处加入死循环，避免协程生成器终止。 注释二：可以看出在执行close()之后协程生成器处于GEN_SUSPENDED状态。即协程正常结束。 异常处理throw()方法可以传入异常。请看示例代码： 123456789101112131415161718192021222324&gt;&gt;&gt; class DemoException(Exception): # 注释一 '''定义的演示异常类型''' pass&gt;&gt;&gt; def coroutine(): print('-&gt; coroutine started') while True: try: x = yield except DemoException: # 注释二 print('*** DemoException handled. Continuing...') else: print('-&gt; coroutine received:', x) raise RuntimeError('This line should never run.') # 注释三 &gt;&gt;&gt; c = coroutine()&gt;&gt;&gt; next(c)-&gt; coroutine started&gt;&gt;&gt; c.send(1)-&gt; coroutine received: 1 &gt;&gt;&gt; c.throw(DemoException) # 注释四*** DemoException handled. Continuing... 注释一：自定义异常类型DemoException。 注释二：特殊处理DemoException类型。 注释三：这一行永远不会执行。 注释四：使用throw()传入异常类型。 本篇讲述的为协程最原始的实现方法，虽然实现与异常处理比较繁琐，但确是协程的实现原理，对于真正理解协程大有裨益。 下篇将与您分享如何使用yield from实现协程。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"asyncio","date":"2019-12-12T12:31:51.000Z","path":"2019/12/12/asyncio/","text":"","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"Python上下文管理器","date":"2019-12-07T09:06:08.000Z","path":"2019/12/07/contextor/","text":"什么是上下文管理器？我们常见的with open操作文件，就是一个上下文管理器。如： 12with open(file, 'rb') as f: text = f.read() 那上下文管理器具体的定义是什么呢？ 上下文管理器：是指在一段代码执行之前执行一段代码，用于一些预处理工作；执行之后再执行一段代码，用于一些清理工作。 比如刚提到的文件操作，打开文件进行读写，读写完之后需要将文件关闭。很明显用到了上下文管理器。主要依靠__enter__、__exit__这两个”魔术方法”实现。 __enter__(self) Defines what the context manager should do at the beginning of the block created by the with statement. Note that the return value of enter is bound to the target of the with statement, or the name after the as. __exit__(self, exception_type, exception_value, traceback) Defines what the context manager should do after its block has been executed (or terminates). It can be used to handle exceptions, perform cleanup, or do something always done immediately after the action in the block. If the block executes successfully, exception_type, exceptionvalue, and traceback will be None. Otherwise, you can choose to handle the exception or let the user handle it; if you want to handle it, make sure _exit__ returns True after all is said and done. If you don’t want the exception to be handled by the context manager, just let it happen. 当我们需要创建一个上下文管理器类型的时候，就需要实现__enter__和__exit__方法，这对方法称为上下文管理协议（Context Manager Protocol），定义了一种运行时上下文环境。 基本语法 12with EXPR as VAR: BLOCK 这里就是一个标准的上下文管理器的使用逻辑，其中的运行逻辑： （1）执行EXPR语句，获取上下文管理器（Context Manager） （2）调用上下文管理器中的enter方法，该方法执行一些预处理工作。 （3）这里的as VAR可以省略，如果不省略，则将enter方法的返回值赋值给VAR。 （4）执行代码块BLOCK，这里的VAR可以当做普通变量使用。 （5）最后调用上下文管理器中的的exit方法。 （6）exit方法有三个参数：exc_type, exc_val, exc_tb。如果代码块BLOCK发生异常并退出，那么分别对应异常的type、value 和 traceback。否则三个参数全为None。 （7）exit方法的返回值可以为True或者False。如果为True，那么表示异常被忽视，相当于进行了try-except操作；如果为False，则该异常会被重新raise。 如何自己实现上下文管理器？简单来说，如果一个类中，实现了__enter__和__exit__方法，那么这个类就是上下文管理器。 12345678910111213141516171819class Contextor(): def __enter__(self): print('程序的预处理开始啦！') return self # 作为as说明符指定的变量的值 def __exit__(self, exc_type, exc_val, exc_tb): print('正在进行收尾！') def func(self): print('程序进行中....')with Contextor() as var: var.func() # 输出程序的预处理开始啦！程序进行中....正在进行收尾！ 从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在__enter__中，而将资源的关闭写在__exit__ 中。 为什么要使用上下文管理器？在我看来，这和 Python 崇尚的优雅风格有关。 可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接； 可以以一种更加优雅的方式，处理异常； 第二种，会被大多数人所忽略。这里着重介绍下。 在处理异常时，通常都是使用try...except...来进行异常处理的。这就可能会出现在程序的主逻辑中有大量的异常处理代码，这会大大影响程序的可读性。 好的做法可以通过with将异常处理隐藏起来。 我们以1/0举例（1/0必然会抛出错误） 123456789101112131415161718class Resource(): def __enter__(self): print('===connect to resource===') return self def __exit__(self, exc_type, exc_val, exc_tb): print('===close resource connection===') return True def operate(self): 1/0with Resource() as res: res.operate() # 输出结果===connect to resource======close resource connection=== 运行发现，并没有出异常。 这就是上下文管理器的强大之处，异常可以在__exit__进行捕获，并自己决定如何处理。在__exit__ 里返回 True（没有return 就默认为 return False），就相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了。 在 写__exit__ 函数时，需要注意的事，它必须要有这三个参数： exc_type：异常类型 exc_val：异常值 exc_tb：异常的错误栈信息 当主逻辑代码没有报异常时，这三个参数将都为None。 如何处理自行处理异常 我们以上面的代码为例，在__exit__加入判断异常的逻辑，如果发生异常，则打印异常信息。 123456789101112131415161718192021class Resource(): def __enter__(self): print('===connect to resource===') return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_type: print(f'出现异常：&#123;exc_type&#125;：&#123;exc_val&#125;') print('===close resource connection===') return True def operate(self): 1/0with Resource() as res: res.operate() # 输出===connect to resource===出现异常：&lt;class 'ZeroDivisionError'&gt;：division by zero===close resource connection=== 如何更好的使用上下文管理器？在Python中有一个专门用于实现上下文管理的标准库contextlib。 有了 contextlib 创建上下文管理的最好方式就是使用 contextmanager 装饰器，通过 contextmanager 装饰一个生成器函数，yield 语句前面的部分被认为是__enter__() 方法的代码，后面的部分被认为是 __exit__()方法的代码。 我们以打开文件为例： 12345678910111213141516171819import contextlib@contextlib.contextmanagerdef open_func(file_name): # __enter__方法 print('open file:', file_name, 'in __enter__') file_handler = open(file_name, 'r') # 【重点】：yield yield file_handler # __exit__方法 print('close file:', file_name, 'in __exit__') file_handler.close() returnwith open_func('/Users/MING/mytest.txt') as file_in: for line in file_in: print(line) 如果要处理异常，将上面代码改写成下面的样子。 1234567891011121314151617181920212223import contextlib@contextlib.contextmanagerdef open_func(file_name): # __enter__方法 print('open file:', file_name, 'in __enter__') file_handler = open(file_name, 'r') try: yield file_handler except Exception as exc: # deal with exception print('the exception was thrown') finally: print('close file:', file_name, 'in __exit__') file_handler.close() returnwith open_func('test.txt') as file_in: for line in file_in: 1/0 print(line) 参考： 123https://juejin.im/post/5c87b165f265da2dac4589cchttps://www.cnblogs.com/linxiyue/p/3855751.htmlhttps://runnerliu.github.io/2018/01/02/pythoncontextmanager/","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"《大话设计模式》——装饰模式（Python版）","date":"2019-11-29T14:46:18.000Z","path":"2019/11/29/designmodel3/","text":"装饰模式：动态地给一个对象添加一些额外的职责，就添加功能来说，装饰模式比生成子类更为灵活。 1. 装饰模式基本实现代码（Python版）1234567891011121314151617181920212223242526272829303132333435363738394041424344import abc class Component(metaclass=abc.ABCMeta): #定义一个对象的接口，可以给这些对象动态地添加职责。 @abc.abstractmethod def Operation(self): pass class ConcreteComponent(Component): # 定义一个具体对象，可以给这个对象添加一些职责。 def Operation(self): print(\"具体对象的操作\") class Decorator(Component): # 抽象装饰类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，无需知道Decorator的存在。 def __init__(self): self._component = Component() def SetComponent(self,component): # 设置Component self._component = component def Operation(self): # 重写Operation()实际执行的市Component的Operation() if(self._component != None): self._component.Operation() class ConcreteDecoratorA(Decorator): # 具体的装饰对象，起到给Component添加职责的功能。 def __init__(self): self.__addedState = None # 本类独有的功能，区别于ConcreteDecoratorB def Operation(self): super(ConcreteDecoratorA,self).Operation() # 先运行原Component的Operation（），再执行本类功能。 self.__addedState = \"New State\" print(\"具体装饰对象A的操作\") class ConcreteDecoratorB(Decorator): # 具体的装饰对象，起到给Component添加职责的功能。 def Operation(self): super(ConcreteDecoratorB,self).Operation() self.AddedBehavior() print(\"具体装饰对象A的操作\") def AddedBehavior(self): # 本类独有的功能，区别于ConcreteDecoratorA pass if __name__ == '__main__': c = ConcreteComponent() d1 = ConcreteDecoratorA() d2 = ConcreteDecoratorB() d1.SetComponent(c) d2.SetComponent(d1) d2.Operation() ​ 装饰模式利用SetComponent来对对象进行包装。每个装饰对象的实现就与如何使用这个对象分开了，每个装饰对象只关心自己的功能，不需要关系如何被添加到对象链当中。 ​ 当只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同理，如果只有一个ConcreteDecorator类，那么没必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任和合并成一个类。 2.使用装饰模式和不使用装饰模式的代码区别例：使用Python设计一个给人搭配不同服饰的系统，控制台模式下即可。 2.1 不使用装饰模式版本一： 12345678910111213141516171819class Person(object): def __init__(self, name): self.__name = name def WearTShits(self): print(\"大T恤\") def WearBigTrouser(self): print(\"垮裤\") def WearSneakers(self): print(\"破球鞋\") def Show(self): print(\"装扮的\",self.__name) if __name__ == '__main__': xc = Person('小菜') print('装扮: ') xc.WearTShits() xc.WearBigTrouser() xc.WearSneakers() xc.Show() 此版本，将人物和穿搭封装成了Person类，所有穿搭都是Person类中的方法。如果有新的装扮，则需要对Person类进行修改，违背了开放-封闭原则。 因此需要将人物和穿搭拆分开。 第二版 1234567891011121314151617181920212223242526272829303132333435from abc import ABCMeta,abstractmethodclass Person(object): def __init__(self,name): self.__name = name def Show(self): print(\"装扮的\",self.__name) class Finery(metaclass=abc.ABCMeta): @abstractmethod def Show(self): pass class TShits(Finery): def Show(self): print(\"大T恤\") class BigTrouser(Finery): def Show(self): print(\"垮裤\") class Sneakers(Finery): def Show(self): print(\"破球鞋\") if __name__ == '__main__': xc = Person('小菜') print('装扮:') dtx = TShits() kk = BigTrouser() pqx = Sneakers() # 装饰过程 dtx.Show() kk.Show() pqx.Show() 此版本，将人物和服饰分别进行封装成Person类和Finery类。Finery类是服饰抽象类，所有具体服饰类都继承于它，如果又新的装扮，则直接添加新的具体服饰类就可以，无需修改Person类和Finery类。但是，在具体使用时，下面的代码显得十分冗余。 123dtx.Show()kk.Show()pqx.Show() 没有将具体的穿搭过程进行封装，犹如公众场合下换衣服的感觉，没有真正体现出先穿什么再穿什么的流程。 2.2 使用装饰模式仿照装饰模式的基本实现代码对上面的代码进行修改， Person类相当于ConcreteComponent类，Finery类相当于Decorator类。因为只有一个ConcreteComponent类而没有抽象的Component类，所以Decorator类可以是ConcreteComponent的一个子类。 修改结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import abc# Person类 class Person(metaclass=abc.ABCMeta): def __init__(self, name): self._name = name def Show(self): print(\"装扮的\",self.__name)# 服饰类class Finery(Person): def __init__(self): pass def Decorate(self, component): self._component = component def Show(self): if self._component is not None: self._component.Show()class TShirts(Finery): def __init__(self): pass def Show(self): print('T恤衫') self._component.Show()class BigTrouser(Finery): def __init__(self): pass def Show(self): print('垮裤') self._component.Show()if __name__ == '__main__': person = Person('小菜') dtx = TShirts() kk = BigTrouser() # 装饰过程 dtx.Decorate(person) kk.Decorate(dtx) kk.Show() 此版本从装饰过程中能明显体会到先穿什么再穿什么的流程。这种写法有效地把类中的核心职责和装饰功能分开，而且可以去除相关重复的装饰逻辑。每个装饰对象只需要关注自己的功能，无需关注如何被添加到对象中的。 3. python中装饰器VS装饰模式看到这里，你可能会联想到Python自带的装饰器@语法糖，那我们谈一谈Python中的装饰器和设计模式中的装饰模式的联系与区别： 设计模式中的装饰模式： 是设计模式的一种。是一种编程思想，与编程语言无关。 是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 Python装饰器： 是Python中的高级函数使用上的一种语法糖。 是对装饰模式的一个更宽泛的应用，不仅仅能够应用于类，也能应用于函数，类方法和类属性。 总结：​ 当系统需要新功能且新功能只是为了满足一些再特定情况下才会执行的特殊行为需要。可以采用装饰模式。 在Python有现成的语法糖支持装饰模式。用于常常被用于有切面需求的场景。较为经典的有插入日志、性能測试、事务处理等。 参考：理解 Python 装饰器看这一篇就够了 Python设计模式之装饰器模式","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mrleecn.cn/tags/设计模式/"}]},{"title":"《大话设计模式》——策略模式（Python版）","date":"2019-11-15T14:19:23.000Z","path":"2019/11/15/designmodel2/","text":"策略模式（Stategy）：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化不会影响到使用算法的客户。 例： 使用Python设计一个控制台收银软件，收银策略包括（正常收银、打八折、满300返100）。要求输入打折策略和总金额，返回实际付款金额。 1.使用简单工厂模式写法通用的收费类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import abc# 现金收费对象class CashSuper(metaclass=abc.ABCMeta): def format_money(self, strNumber): ''' 将字符串格式的金额，转化成float类型，并保留两位小数 :param strNumber: :return: ''' return round(float(strNumber), 2) @abc.abstractmethod def acceptCash(self, money): pass# 正常收费子类class CashNormal(CashSuper): def acceptCash(self, money): return self.format_money(money)# 打折收费子类class CashRebate(CashSuper): def __init__(self, moneyRabate=1): self.moneyRabate = self.format_money(moneyRabate) # 打折率 def acceptCash(self, money): return self.format_money(money) * self.moneyRabate# 返利收费类class CashReturn(CashSuper): def __init__(self, moneyCondition, moneyReturn): self.moneyCondition = self.format_money(moneyCondition) self.moneyReturn = self.format_money(moneyReturn) def acceptCash(self, money): money = self.format_money(money) if money &gt; self.moneyCondition: money -= money / self.moneyCondition * self.moneyReturn return self.format_money(money) 说明： 现金收费对象（CashSuper） 为其他三种收银策略的抽象类。 正常收费子类（CashNormal） 继承于CashSuper类，重写CashSuper类的acceptCash方法。正常收费，返回原价。 打折收费子类（CashRebate） 继承于CashSuper类，重写CashSuper类的acceptCash方法。用于处理打折策略，初始化传入折扣率，返回打折后的金额。 返利收费子类（CashReturn） 继承于CashSuper类，重写CashSuper类的acceptCash方法。用于处理返利策略，初始化时传入返利条件和返利金额。返回满减后的金额。 123456789101112131415161718192021# 现金收费工厂类class CashFactory(object): def createCashAccept(self, type): if type == '正常收费': cs = CashNormal() elif type == '满300返100': cs = CashReturn(300, 100) elif type == '打八折': cs = CashRebate(0.8) return cs# 客户端if __name__ == '__main__': cf = CashFactory() cs = cf.createCashAccept('满300返100') print(cs.acceptCash(1000)) # 输出666.67 2.使用策略模式写法123456789101112131415161718192021222324# CashContext类class CashContext(object): def __init__(self, csuper): self.cs = csuper def GetResult(self, money): return self.cs.acceptCash(money)# 客户端if __name__ == '__main__': type = '满300返100' # 收银策略 if type == '正常收费': cc = CashContext(CashNormal()) elif type == '满300返100': cc = CashContext(CashReturn(300, 100)) elif type == '打八折': cc = (CashRebate(0.8)) print(cc.GetResult(1000)) # 1000为总金额 # 输出666.67 3.使用策略模式+简单工厂模式123456789101112131415161718192021# CashContext类class CashContext(object): # 将工厂类对各种子类的初始化合并到策略模式的构造函数中 def __init__(self, type): if type == '正常收费': self.cs = CashNormal() elif type == '满300返100': self.cs = CashReturn(300, 100) elif type == '打八折': self.cs = CashRebate(0.8) def GetResult(self, money): return self.cs.acceptCash(money)# 客户端if __name__ == '__main__': cc = CashContext('满300返100') print(cc.GetResult(1000)) # 输出666.67 4.对比总结对比： 简单工厂模式： 将各种收银策略的子类对象在工厂中进行实例化。 客户端需要先创建工厂类；然后再工厂类中传入收银策略，进行初始化对应的策略子类；最后才传入总金额计算。在这过程中，共实例化了两个对象（cf、cs）。 如果添加新的收银策略，需要增加对应的收费子类，并修改工厂中对应部分。无需修改客户端。 策略模式： 在CashContext的构造函数中，传入具体的收银策略对象，在GetResult方法中根据具体的收银策略对象调用其算法。 客户端需要对具体收银策略进行判断，生成具体的收银策略对象，然后传入到CashContext中。最后传入总金额计算。 如果添加新的收银策略，需要增加对应的收费子类，并对客户端代码进行修改。 策略模式+简单工厂模式： 在CashContext的构造函数中将各种收银策略的子类对象实例化。在GetResult方法中根据具体的收银策略对象调用其算法。 客户端只需要实例化一个CashContext对象，然后直接可以传入总金额计算。 如果添加新的收银策略，需要增加对应的收费子类，并修改CashContext类中对应部分。无需修改客户端。 总结： 简单工厂模式用于解决对象的创建问题，策略模式用于封装算法。 策略模式简化了单元测试。因为每个算法都有自己的类，可以通过自己的接口进行单独测试。 只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式来处里这种变化的可能。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mrleecn.cn/tags/设计模式/"}]},{"title":"《大话设计模式》——简单工厂模式（Python版）","date":"2019-11-12T13:20:37.000Z","path":"2019/11/12/designmodel1/","text":"简单工厂模式(Simple Factory Pattern)：是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类. 例：使用Python设计一个控制台计算器，要求输入两个数和运算符号，得到运算结果。 1. 初学者写法12345678910111213141516171819202122232425262728293031323334353637class Operation(object): def __init__(self): pass def conver_strNumber(self, strNumber): ''' 将字符串格式的数字，转化成对应格式的数字 :param strNumber: :return: ''' if '.' not in strNumber: return int(strNumber) else: return float(strNumber) def op(self, strNumberA, strNumberB, strOperate): if strOperate == '+': return self.conver_strNumber(strNumberA) + self.conver_strNumber(strNumberB) elif strOperate == '-': return self.conver_strNumber(strNumberA) - self.conver_strNumber(strNumberB) elif strOperate == '*': return self.conver_strNumber(strNumberA) * self.conver_strNumber(strNumberB) elif strOperate == '/': if strNumberB != '0' and strNumberB != '0.0': return self.conver_strNumber(strNumberA) / self.conver_strNumber(strNumberB) else: return 0 else: print('只能做加减乘除运算')if __name__ == '__main__': p = Operation() print(p.op('2.2', '1', '+')) # 输出21.2 分析：以上这种写法，将加减乘除运算全部放在一个类中实现，虽然实现了计算器的功能，但增加其他运算或修改某个运算都必须在Operation类中进行修改。 使得程序不容易维护、扩展以及复用，并且耦合性高。 2.使用简单工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Operation运算类class Operation(object): def __init__(self, strNumberA=0, strNumberB=0): self.NumberA = strNumberA self.NumberB = strNumberB def conver_strNumber(self, strNumber): ''' 将字符串格式的数字，转化成对应格式的数字 :param strNumber: :return: ''' if '.' not in strNumber: return int(strNumber) else: return float(strNumber) def GetResult(self): pass# 加法运算类class OperationAdd(Operation): def GetResult(self): return self.conver_strNumber(self.NumberA) + self.conver_strNumber(self.NumberB)# 减法运算类class OperationSub(Operation): def GetResult(self): return self.conver_strNumber(self.NumberA) - self.conver_strNumber(self.NumberB)# 乘法运算类class OperationMul(Operation): def GetResult(self): return self.conver_strNumber(self.NumberA) * self.conver_strNumber(self.NumberB)# 除法运算类class OperationDiv(Operation): def GetResult(self): if self.NumberB != 0 and self.NumberB != 0.0: return self.conver_strNumber(self.NumberA) / self.conver_strNumber(self.NumberB) else: return '除数不能为0'# 其他操作符运算class OperationUndef(Operation): def GetResult(self): return '操作符错误'# 简单工厂类class OperationFactory(object): def createOperate(self, operate): if operate == '+': return OperationAdd() elif operate == '-': return OperationSub() elif operate == '*': return OperationMul() elif operate == '/': return OperationDiv() else: return OperationUndef()if __name__ == '__main__': strNumA = '1.0' strNumB = '2' oper = '/' OP = OperationFactory() oper_obj = OP.createOperate(oper) oper_obj.NumberA = strNumA oper_obj.NumberB = strNumB result = oper_obj.GetResult() print(result) # 输出0.5 分析：将各种运算拆分成单独的类，均继承于Operation类，各运算子类重写Operation类中的GetResult()方法。统一通过简单工厂类（OperationFactory类）实例化运算所需的运算子类。 这样设计的优点： 易扩展 如果添加新的运算类，只需要 新的运算类继承Operation类，并重写GetResult()方法 在简单工厂类（OperationFactory类）中添加对应的if语句 无需对其他运算类进行操作。 易维护 对某一运算类进行修改，并不涉及其他运算类，很大程度上避免了由于误操作而对其他运算类修改的问题。 低耦合 各运算类只公共继承Operation类，不涉及其他运算类。 高复用 无论是控制台，还是windows程序，Web程序，均可使用该程序实现计算器功能。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://mrleecn.cn/tags/设计模式/"}]},{"title":"财务自由之路读书笔记——负债篇","date":"2019-09-19T14:49:45.000Z","path":"2019/09/19/caiwuziyou6/","text":"债务产生的原因债务一般产生于某一个人想要避免眼下痛苦的时候：一个人买不起自己喜欢的东西，就意味着放弃，放弃就意味着痛苦。而人的大脑总偏向于享受快乐，避免痛苦。 如何避免债务人们总趋向于享受快乐，避免痛苦。但什么是快乐，什么是痛苦，这是由我们的信仰决定的。因此，想要解决债务问题，就需要从改变有关于金钱的信仰开始。 如何改变金钱观消除债务的几个有用技巧根据自身的情况，总结出了这几个方法： 制定远大的目标，并努力向其靠近。 改变自己对于金钱的信仰。 拒绝消费债。消费债毫无有点。 永远不要说：“这没用”。每一块钱都有用。 记录自己的每一笔开支，制定消费计划，严格按照计划执行。 拒绝使用信用卡，花呗，白条等产品。 消费前，问一问自己，这笔支出真的有必要吗？ 寻找新的收入来源。 开始储蓄。不要用能存下来的钱数额的50%以上偿还债务。 不要用能存下来的钱数额的50%以上偿还债务。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"}]},{"title":"AES中ECB模式的加密与解密（Python3.7）","date":"2019-09-16T12:38:05.000Z","path":"2019/09/16/pythonaes/","text":"本文主要解决的问题本文主要是讲解AES加密算法中的ECB模式的加密解密的Python3.7实现。具体AES加密算法的原理这里不做过多介绍，想了解的可以参考文末的参考链接。 主要解决了两个问题： 在Python3.7版本下，所依赖包的安装问题。（有一些博客时间久远，其中所提到的模块并不适用于Python3.7） 因为Python版本的问题，其他博客在基于Python3.6下的代码在Python3.7下并不能运行的问题。 背景介绍在爬虫项目中遇到，某些网站的账号、密码采用了AES的ECB模式进行了加密。 123456# 加密前的数据123456asd# 加密后的数据3cfeba82c31b6635e8fb085e04529e74# 密钥8NONwyJtHesysWpM 使用在线AES加密解密、AES在线加密解密，进行尝试。 mark 经过测试发现，在AES加密的ECB模式，填充为pkcs7padding ，数据块为128位，输出格式为hex时，得到自己想要的结果。 （这里可以可以根据密文的格式进行判断输出的格式，一般密文以==结尾的输出格式为base64，否则为hex格式） 问题1：Crypto模块安装报错pip 安装 pycrypto模块，抛如下错误: 1error: command 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\BIN\\\\cl.exe' failed with exit status 2 解决方法： 详见python3.7安装pycrypto。 问题2：网上copy来的代码报错在网上博客中直接copy来的代码，可能会抛如下错误。 1TypeError: Object type &lt;class 'str'&gt; cannot be passed to C code 换个博客，发现依旧是这个错误。 错误原因： 之前版本的代码并不适用于Python3.7。需要进行修改。 修改后的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import base64from Crypto.Cipher import AESimport binasciidef add_to_16(text): while len(text) % 16 != 0: text += '\\0' return textdef encrypt(data, password): if isinstance(password, str): password = password.encode('utf8') bs = AES.block_size pad = lambda s: s + (bs - len(s) % bs) * chr(bs - len(s) % bs) cipher = AES.new(password, AES.MODE_ECB) data = cipher.encrypt(pad(data).encode('utf8')) encrypt_data = binascii.b2a_hex(data) # 输出hex # encrypt_data = base64.b64encode(data) # 取消注释，输出Base64格式 return encrypt_data.decode('utf8')def decrypt(decrData, password): if isinstance(password, str): password = password.encode('utf8') cipher = AES.new(password, AES.MODE_ECB) plain_text = cipher.decrypt(binascii.a2b_hex(decrData)) return plain_text.decode('utf8').rstrip('\\0')if __name__ == '__main__': data = '123456asd' # 待加密数据 password = '8NONwyJtHesysWpM' # 16,24,32位长的密码（密钥） password = add_to_16(password) encrypt_data = encrypt(data, password) print('加密前数据：&#123;&#125;\\n======================='.format(data)) print('加密后的数据:', encrypt_data) decrypt_data = decrypt(encrypt_data, password) print('解密后的数据：&#123;&#125;'.format(decrypt_data)) mark 参考python 加密解密 AES ECB PKCS5/PKCS7 加解密 python实现 支持中文 python3.7 利用Crypto进行AES解密&amp;加密文件 python3.7安装pycrypto","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"加密","slug":"加密","permalink":"https://mrleecn.cn/tags/加密/"}]},{"title":"【docker】CentOS6.8+Python2.7+selenium+Firefox的搭建","date":"2019-08-05T09:11:25.000Z","path":"2019/08/05/centos68py27/","text":"当前Docker容器配置： Centos6.8 python2.6.6 目标Docker容器配置： Centos6.8 python2.7 selenium 3.141.0 geckodriver 0.15 firefox 52.8.0 Pillow 6.1.0 pytesseract 0.2.7 安装依赖环境1yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make wget git unzip gcc gcc-c++ libjpeg-devel libpng-devel libgif-devel 创建目录存放安装包12mkdir /usr/local/download cd /usr/local/download 安装Python2.7123456789101112131415161718192021222324# 安装python2.7wget https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tgztar -zxvf Python-2.7.15.tgz cd Python-2.7.15./configuremake &amp;&amp; make installmv /usr/bin/python /usr/bin/python_bakln -s /usr/local/bin/python2.7 /usr/bin/python# 安装pipwget --no-check-certificate https://bootstrap.pypa.io/get-pip.pypython get-pip.pyln -s /usr/local/bin/pip /usr/bin/pip# 配置pip源（豆瓣）cd mkdir .pipcd .pipvi pip.conf#写入如下内容:[global]index-url=http://pypi.douban.com/simpletrusted-host = pypi.douban.com 安装tesseract1234567891011121314151617181920212223242526272829303132# 先安装leptonicacd /usr/local/downloadwget http://www.leptonica.org/source/leptonica-1.72.tar.gztar xvzf leptonica-1.72.tar.gzcd leptonica-1.72/./configuremake &amp;&amp; make install# 安装tesseractcd /usr/local/downloadwget https://github.com/tesseract-ocr/tesseract/archive/3.04.zipunzip 3.04.zip cd tesseract-3.04/./configuremake &amp;&amp; make install# 手动更新动态链接库ldconfig# pip安装pytesseractpip install pytesseract# 安装语言包在https://github.com/tesseract-ocr/tessdata 下载对应语言的模型文件由于目前只需要识别手机号码和英文，只下载一个eng.traineddata文件即可，将模型文件移动到/usr/local/share/tessdata然后即可进行识别# 示例import pytesseractfrom PIL import Imageimage = Image.open('bb.png')code = pytesseract.image_to_string(image)print(code) 安装selenium+firefox+geckodriver安装selenium 1234pip install selenium# 查看版本pip show selenium 安装geckodriver 123456cd /usr/local/downloadwget https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-linux64.tar.gztar xvzf geckodriver-*.tar.gzrm -f /usr/bin/geckodriver# 软链接必须用绝对路径ln -s /usr/local/download/geckodriver /usr/bin/geckodriver 安装firefox 123cd /usr/local/downloadwget http://www.rpmfind.net/linux/centos/6.10/os/x86_64/Packages/firefox-52.8.0-1.el6.centos.x86_64.rpmyum install -y firefox-52.8.0-1.el6.centos.x86_64.rpm 安装中文字体 1234567891011121314151617# 新建字体目录 chinese：mkdir /usr/share/fonts/chinese# 将windows系统盘 c:\\windows\\fonts\\中的字体直接上传至 centos 的 /usr/share/fonts/chinese目录下即可chmod -R 755 /usr/share/fonts/chineseyum -y install ttmkfdirttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dir# 修改fonts.conf的Font directory list，即字体列表，在这里需要把我们添加的中文字体位置加进去：vi /etc/fonts/fonts.conf&lt;dir&gt;/usr/share/fonts/chinese&lt;/dir&gt;# 刷新内存中的字体缓存，这样就不用reboot重启了：fc-cache# 最后再次通过fc-list看一下字体列表： fc-list 安装 xvfb在Linux中有1个很好用的工具xvfb,它是1个X服务可以用于在没有显示器的硬件和物理输入设备上运行 12345a,安装必需的软件包[cat@localhost ~]# yum install -y xdg-utils xorg-x11-server-Xvfb xorg-x11-xkb-utilsa,安装xvfb的绑定[cat@localhost ~]# pip install xvfbwrapper pyvirtualdisplay 测试用例： 12345678910111213#!/usr/bin/python# -*- coding:utf-8 -*-from selenium import webdriverfrom pyvirtualdisplay import Displayfrom selenium.webdriver.firefox.firefox_binary import FirefoxBinarydisplay = Display(visible=0, size=(800,600))display.start()binary = FirefoxBinary('/usr/bin/firefox')driver = webdriver.Firefox(firefox_binary=binary)driver.get('https://www.baidu.com')print(driver.title.encode('utf8'))driver.quit()display.stop() pip安装所需包12345#安装包pip install requestspip install Pillowpip install httplib2pip install excel 参考： CentOS6.8 安装python2.7，pip以及yum","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"https://mrleecn.cn/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"【docker】CentOS7.4+Python2.7+selenium+Firefox+tesseract的搭建","date":"2019-08-04T09:11:17.000Z","path":"2019/08/04/centos74py27/","text":"当前Docker容器配置： Centos7.4 python2.7.5 目标Docker容器配置： Centos7.4 python2.7.5 selenium 3.141.0 geckodriver 0.15 firefox 56.0.2 Pillow 6.1.0 pytesseract 0.2.7 安装依赖环境1yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make wget git unzip gcc gcc-c++ libjpeg-devel libpng-devel libgif-devel 创建目录存放安装包12mkdir /usr/local/download cd /usr/local/download 安装pip1234wget --no-check-certificate https://bootstrap.pypa.io/get-pip.pypython get-pip.pymv /usr/bin/pip /usr/bin/pip_bakln -s /usr/local/bin/pip /usr/bin/pip 根据需求安装所需包1234pip install requestspip install Pillowpip install httplib2pip install excel 安装tesseract12345678910111213141516171819202122232425262728293031# 安装leptonicacd /usr/local/download/wget http://www.leptonica.org/source/leptonica-1.72.tar.gztar xvzf leptonica-1.72.tar.gzcd leptonica-1.72/./configuremake &amp;&amp; make install# 安装tesseract-3.04cd /usr/local/download/wget https://github.com/tesseract-ocr/tesseract/archive/3.04.zipunzip 3.04.zip &amp;&amp; cd tesseract-3.04/./configuremake &amp;&amp; make install# 手动更新动态链接库ldconfigpip install pytesseract# 安装语言包在https://github.com/tesseract-ocr/tessdata 下载对应语言的模型文件由于目前只需要识别手机号码和英文，只下载一个eng.traineddata文件即可，将模型文件移动到/usr/local/share/tessdata然后即可进行识别# 示例import pytesseractfrom PIL import Imageimage = Image.open('bb.png')code = pytesseract.image_to_string(image)print(code) 安装selenium+Firefox+Xvfb123456789101112131415yum install -y Xvfb gtk3 gtk3-devel libXfont xorg-x11-fonts* libgtk-3.so.0 bzip2 pip install xvfbwrapper selenium pyvirtualdisplay# 安装浏览器cd /usr/local/download/wget https://ftp.mozilla.org/pub/firefox/releases/56.0.2/linux-x86_64/en-US/firefox-56.0.2.tar.bz2tar xjvf firefox-56.0.2.tar.bz2rm -f /usr/bin/firefoxln -s /usr/local/download/firefox/firefox /usr/bin/firefox# 安装geckodriverwget https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-linux64.tar.gztar xvzf geckodriver-*.tar.gzrm -f /usr/bin/geckodriverln -s /usr/local/download/geckodriver /usr/bin/geckodriver # 软链接必须用绝对路径 测试用例： 12345678910111213#!/usr/bin/python# -*- coding:utf-8 -*-from selenium import webdriverfrom pyvirtualdisplay import Displayfrom selenium.webdriver.firefox.firefox_binary import FirefoxBinarydisplay = Display(visible=0, size=(800,600))display.start()binary = FirefoxBinary('/usr/bin/firefox')driver = webdriver.Firefox(firefox_binary=binary)driver.get('https://www.baidu.com')print(driver.title.encode('utf8'))driver.quit()display.stop()","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"https://mrleecn.cn/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"【docker】CentOS7.4+Python3.7+selenium+Firefox+tesseract的搭建","date":"2019-08-03T09:10:59.000Z","path":"2019/08/03/centos74py37/","text":"当前Docker容器配置： Centos7.4 python2.7.5 目标Docker容器配置： Centos7.4 python3.7.4 selenium 3.141.0 geckodriver 0.15 firefox 56.0.2 Pillow 6.1.0 pytesseract 0.2.7 安装依赖环境1[root@bf8feb8d5089 /]# yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make wget git unzip gcc gcc-c++ libjpeg-devel libpng-devel libgif-devel 创建目录存放安装包12[root@bf8feb8d5089 /]# mkdir /usr/local/download [root@bf8feb8d5089 /]# cd /usr/local/download 安装Python3.7.412345678910111213141516171819202122232425262728293031323334353637[root@bf8feb8d5089 /]# cd /usr/local/download[root@bf8feb8d5089 download]# wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz[root@bf8feb8d5089 download]# tar -xvf Python-3.7.4.tgz# 编译[root@bf8feb8d5089 download]# cd Python-3.7.4[root@bf8feb8d5089 Python-3.7.4]# ./configure # 编译和安装[root@bf8feb8d5089 Python-3.7.4]# make &amp;&amp; make install# 备份源文件[root@bf8feb8d5089 Python-3.7.4]# mv /usr/bin/python /usr/bin/python.bak# 软连接[root@bf8feb8d5089 Python-3.7.4]# find / -name python3/usr/local/bin/python3[root@bf8feb8d5089 Python-3.7.4]# ln -s /usr/local/bin/python3 /usr/bin/python[root@bf8feb8d5089 Python-3.7.4]# ln -s /usr/local/bin/pip3 /usr/bin/pip# 修改yum文件（因为yum是python2写的）[root@bf8feb8d5089 Python-3.7.4]# vi /usr/bin/yum将第一行python改为python2.7如果存在/usr/libexec/urlgrabber-ext-down，则将其中的python也改了# 配置pip源[root@bf8feb8d5089 Python-3.7.4]# cd [root@bf8feb8d5089 ~]# mkdir .pip[root@bf8feb8d5089 ~]# vi .pip/pip.conf#写入如下内容[global]index-url=http://pypi.douban.com/simpletrusted-host = pypi.douban.com 根据需求安装所需包1234[root@bf8feb8d5089 ~]# pip install requests[root@bf8feb8d5089 ~]# pip install Pillow[root@bf8feb8d5089 ~]# pip install httplib2[root@bf8feb8d5089 ~]# pip install excel 安装tesseract1234567891011121314151617181920212223242526272829303132# 安装leptonica[root@bf8feb8d5089 ~]# cd /usr/local/download/[root@bf8feb8d5089 download]# wget http://www.leptonica.org/source/leptonica-1.72.tar.gz[root@bf8feb8d5089 download]# tar xvzf leptonica-1.72.tar.gz[root@bf8feb8d5089 download]# cd leptonica-1.72/[root@bf8feb8d5089 leptonica-1.72]# ./configure[root@bf8feb8d5089 leptonica-1.72]# make &amp;&amp; make install# 安装tesseract-3.04[root@bf8feb8d5089 leptonica-1.72]# cd ..[root@bf8feb8d5089 download]# wget https://github.com/tesseract-ocr/tesseract/archive/3.04.zip[root@bf8feb8d5089 download]# unzip 3.04.zip &amp;&amp; cd tesseract-3.04/[root@bf8feb8d5089 tesseract-3.04]# ./configure[root@bf8feb8d5089 tesseract-3.04]# make &amp;&amp; make install# 手动更新动态链接库[root@bf8feb8d5089 tesseract-3.04]# ldconfig[root@bf8feb8d5089 tesseract-3.04]# pip install pytesseract# 安装语言包在https://github.com/tesseract-ocr/tessdata 下载对应语言的模型文件由于目前只需要识别手机号码和英文，只下载一个eng.traineddata文件即可，将模型文件移动到/usr/local/share/tessdata然后即可进行识别# 示例import pytesseractfrom PIL import Imageimage = Image.open('bb.png')code = pytesseract.image_to_string(image)print(code) 安装selenium+Firefox+Xvfb123456789101112131415[root@bf8feb8d5089 tesseract-3.04]# yum install -y Xvfb gtk3 gtk3-devel libXfont xorg-x11-fonts* libgtk-3.so.0 bzip2 [root@bf8feb8d5089 tesseract-3.04]# pip install xvfbwrapper selenium pyvirtualdisplay# 安装浏览器[root@bf8feb8d5089 tesseract-3.04]# cd /usr/local/download/[root@bf8feb8d5089 download]# wget https://ftp.mozilla.org/pub/firefox/releases/56.0.2/linux-x86_64/en-US/firefox-56.0.2.tar.bz2[root@bf8feb8d5089 download]# tar xjvf firefox-56.0.2.tar.bz2[root@bf8feb8d5089 download]# rm -f /usr/bin/firefox[root@bf8feb8d5089 download]# ln -s /usr/local/download/firefox/firefox /usr/bin/firefox# 安装geckodriver[root@bf8feb8d5089 download]# wget https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-linux64.tar.gz[root@bf8feb8d5089 download]# tar xvzf geckodriver-*.tar.gz[root@bf8feb8d5089 download]# rm -f /usr/bin/geckodriver[root@bf8feb8d5089 download]# ln -s /usr/local/download/geckodriver /usr/bin/geckodriver # 软链接必须用绝对路径 测试用例： 12345678910111213#!/usr/bin/python# -*- coding:utf-8 -*-from selenium import webdriverfrom pyvirtualdisplay import Displayfrom selenium.webdriver.firefox.firefox_binary import FirefoxBinarydisplay = Display(visible=0, size=(800,600))display.start()binary = FirefoxBinary('/usr/bin/firefox')driver = webdriver.Firefox(firefox_binary=binary)driver.get('https://www.baidu.com')print(driver.title)driver.quit()display.stop()","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"https://mrleecn.cn/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"centos_docker","date":"2019-08-02T09:19:28.000Z","path":"2019/08/02/centos-docker/","text":"CentOS7的docker的安装和配置记录1. 安装dockerDocker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#查看你当前的内核版本[root@localhost ~]# uname -r3.10.0-957.el7.x86_64#安装 Docker[root@localhost ~]# yum install -y docker#启动 Docker 后台服务[root@localhost ~]# service docker startRedirecting to /bin/systemctl start docker.service#测试运行 hello-world,由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。[root@localhost ~]# docker run hello-worldUnable to find image 'hello-world:latest' locallyTrying to pull repository docker.io/library/hello-world ...latest: Pulling from docker.io/library/hello-world1b930d010525: Pull completeDigest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20fStatus: Downloaded newer image for docker.io/hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly....# 查看docker版本[root@localhost ~]# docker versionClient: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64 Experimental: false# 设置开机自启动[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 2.更换镜像源修改/etc/docker/daemon.json 123&#123; \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]&#125; 重新启动docker服务 1[root@localhost ~]# systemctl restart docker 3.pull 镜像查看centos的具体版本号（https://hub.docker.com/_/centos） 12345678910111213141516171819202122# centos6.8[root@localhost ~]# docker image pull centos:6.8Trying to pull repository docker.io/library/centos ...6.8: Pulling from docker.io/library/centos7ce0cebb9dca: Pull completeDigest: sha256:39abd0c8e375de6fb7334d42ec2a46643f34cbc1bbaf37e2b484065f05eaa7a2Status: Downloaded newer image for docker.io/centos:6.8# centos7.4[root@localhost ~]# docker image pull centos:7.4.1708Trying to pull repository docker.io/library/centos ...7.4.1708: Pulling from docker.io/library/centos840caab23da4: Pull completeDigest: sha256:8906d699cbd9406b07a105bedebc14a5945c200971b0a3a067aa245badc545b2Status: Downloaded newer image for docker.io/centos:7.4.1708# 查看当前镜像[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/centos 6.8 82f3b5f3c58f 4 months ago 195 MBdocker.io/centos 7.4.1708 9f266d35e02c 4 months ago 197 MBdocker.io/hello-world latest fce289e99eb9 7 months ago 1.84 kB 4. 利用镜像生成容器123# 以centos7.4+py3.7为例（指定容器名为centos7.4_py3.7，使用版本为7.4.1708的centos镜像， 生成容器后的第一个命令为进入bash界面）[root@localhost ~]# docker run --name centos7.4_py3.7 -it centos:7.4.1708 bash[root@bf8feb8d5089 /]# （此时已经进入该容器中） 配置各种组合的Docker1. Centos6.8+python2.7 【docker】CentOS6.8+Python2.7+selenium+Firefox的搭建 2. Centos6.8+python3.7 【docker】CentOS6.8+Python3.7+selenium+Firefox的搭建 3. Centos7.4+python2.7 【docker】CentOS7.4+Python2.7+selenium+Firefox+tesseract的搭建 4. Centos7.4+python3.7【docker】CentOS7.4+Python3.7+selenium+Firefox+tesseract的搭建 【附】常用命令查看镜像1docker images 查看容器12345# 查看全部容器docker ps -a# 查看正在运行的容器docker ps 结束后台运行的docker容器1docker kill [id] 运行一个容器123docker run --name centos7.4_py3.7 -it centos:7.4.1708 bash或docker run -it python:3.7 /bin/bash 进入运行中的容器1docker exec -it [容器id 或 容器名] /bin/bash 启动、关闭、删除全部容器12345678910111213docker中 启动所有的容器命令docker start $(docker ps -a | awk '&#123; print $1&#125;' | tail -n +2)docker中 关闭所有的容器命令docker stop $(docker ps -a | awk '&#123; print $1&#125;' | tail -n +2)docker中 删除所有的容器命令docker rm $(docker ps -a | awk '&#123; print $1&#125;' | tail -n +2)docker中 删除所有的镜像docker rmi $(docker images | awk '&#123;print $3&#125;' |tail -n +2)tail -n +2 表示从第二行开始读取 复制到容器中1docker cp 宿主机文件目录 容器id:容器内文件目录 参考 Docker —— 从入门到实践","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"https://mrleecn.cn/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"【docker】CentOS6.8+Python3.7+selenium+Firefox的搭建","date":"2019-08-02T09:10:38.000Z","path":"2019/08/02/centos68py37/","text":"当前Docker容器配置： Centos6.8 python2.6.6 openssl-1.0.1 目标Docker容器配置： Centos6.8 python3.7.4 openssl-1.1.1 selenium 3.141.0 geckodriver 0.15 firefox 52 Pillow 6.1.0 pytesseract 0.2.7 安装依赖环境1yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make wget git unzip gcc gcc-c++ libjpeg-devel libpng-devel libgif-devel 创建目录存放安装包12mkdir /usr/local/download cd /usr/local/download 安装Python3.7.41.安装最新版本的openssl可能会遇到的问题： centos6.8 默认的openssl版本为1.0.1，而Python3.7需要的openssl版本最低为1.0.2，所以先安装最新版本的openssl。 123456cd /usr/local/downloadwget http://www.openssl.org/source/openssl-1.1.1.tar.gztar -zxvf openssl-1.1.1.tar.gzcd openssl-1.1.1./config --prefix=/usr/local/openssl shared zlibmake &amp;&amp; make install 设置环境变量LD_LIBRARY_PATH 12echo \"export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/openssl/lib\" &gt;&gt; $HOME/.bash_profilesource $HOME/.bash_profile 这一步一定要有！！LD_LIBRARY_PATH环境变量主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。当执行函数动态链接.so时，如果此文件不在缺省目录下/lib and /usr/lib，那么就需要指定环境变量LD_LIBRARY_PATH 2.安装python源码12345678910111213141516171819202122232425262728293031323334cd /usr/local/downloadwget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgztar -xvf Python-3.7.4.tgzcd Python-3.7.4# 编译 一定要指定刚才安装的1.1.1版本的openssl！！！./configure --prefix=/usr/local/python-3.7 --with-openssl=/usr/local/openssl# 优化（执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量）#./configure --enable-optimizations(不要执行，执行后python在导入ssl等相关包时会报错)# 编译和安装make &amp;&amp; make install# 备份原来的pythonmv /usr/bin/python /usr/bin/python.bak# 软连接ln -s /usr/local/python-3.7/bin/python3 /usr/bin/pythonln -s /usr/local/python-3.7/bin/pip3 /usr/bin/pip# 修改yum文件（因为yum是python2写的）vi /usr/bin/yum将第一行python改为python2.6如果存在/usr/libexec/urlgrabber-ext-down，则将其中第一行的python改为python2.6# 配置pip源（豆瓣）[root@localhost ~]# cd [root@localhost ~]# mkdir .pip[root@localhost ~]# cd .pip[root@localhost .pip]# vi pip.conf#写入如下内容:[global]index-url=http://pypi.douban.com/simpletrusted-host = pypi.douban.com 安装tesseract12345678910111213141516171819202122232425262728293031# 先安装leptonicacd /usr/local/downloadwget http://www.leptonica.org/source/leptonica-1.72.tar.gztar xvzf leptonica-1.72.tar.gzcd leptonica-1.72/./configuremake &amp;&amp; make install# 安装tesseractcd /usr/local/downloadwget https://github.com/tesseract-ocr/tesseract/archive/3.04.zipunzip 3.04.zip cd tesseract-3.04/./configuremake &amp;&amp; make installldconfig# pip安装pytesseractpip install pytesseract# 安装语言包在https://github.com/tesseract-ocr/tessdata 下载对应语言的模型文件由于目前只需要识别手机号码和英文，只下载一个eng.traineddata文件即可，将模型文件移动到/usr/local/share/tessdata然后即可进行识别# 示例import pytesseractfrom PIL import Imageimage = Image.open('bb.png')code = pytesseract.image_to_string(image)print(code) 安装selenium+firefox+geckodriver安装selenium 1234pip install selenium# 查看版本pip show selenium 安装geckodriver 123456cd /usr/local/downloadwget https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-linux64.tar.gztar xvzf geckodriver-*.tar.gzrm -f /usr/bin/geckodriver# 软链接必须用绝对路径ln -s /usr/local/download/geckodriver /usr/bin/geckodriver 安装firefox 123cd /usr/local/downloadwget http://www.rpmfind.net/linux/centos/6.10/os/x86_64/Packages/firefox-52.8.0-1.el6.centos.x86_64.rpmyum install -y firefox-52.8.0-1.el6.centos.x86_64.rpm 安装中文字体 1234567891011121314151617# 新建字体目录 chinese：mkdir /usr/share/fonts/chinese# 将windows系统盘 c:\\windows\\fonts\\中的字体直接上传至 centos 的 /usr/share/fonts/chinese目录下即可chmod -R 755 /usr/share/fonts/chineseyum -y install ttmkfdirttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dir# 修改fonts.conf的Font directory list，即字体列表，在这里需要把我们添加的中文字体位置加进去：vi /etc/fonts/fonts.conf&lt;dir&gt;/usr/share/fonts/chinese&lt;/dir&gt;# 刷新内存中的字体缓存，这样就不用reboot重启了：fc-cache# 最后再次通过fc-list看一下字体列表： fc-list 安装 xvfb在Linux中有1个很好用的工具xvfb,它是1个X服务可以用于在没有显示器的硬件和物理输入设备上运行 12345a,安装必需的软件包[cat@localhost ~]# sudo yum install xdg-utils xorg-x11-server-Xvfb xorg-x11-xkb-utilsa,安装xvfb的绑定[cat@localhost ~]# pip install xvfbwrapper pyvirtualdisplay pip安装所需包12345#安装包pip install requestspip install Pillowpip install httplib2pip install excel 参考： centos 解决python3.7 安装时No module named _ssl","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"https://mrleecn.cn/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"Centos7 安装tesseract -ocr报错处理","date":"2019-08-01T15:13:09.000Z","path":"2019/08/01/Centos-tesseract/","text":"环境 CentOS7.4 Python3.7 leptonica-1.72 tesseract-3.04 编译安装 报错12raise TesseractError(proc.returncode, get_errors(error_string))pytesseract.pytesseract.TesseractError: (1, 'Tesseract Open Source OCR Engine v3.04.02dev with Leptonica Error in pixReadMemPng: function not present Error in pixReadMem: png: no pix returned Error during processing.') 问题原因及解决方式缺少依赖包。 安装依赖包 1yum install -y libjpeg-devel libpng-devel libgif-devel 重新编译leptonica 12345# 1.进入leptonica目录略# 2.编译安装./configure make &amp;&amp; make install 问题解决。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://mrleecn.cn/tags/Linux/"},{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"}]},{"title":"Pyhon爬虫Post上传文件的两种方法","date":"2019-07-21T09:44:09.000Z","path":"2019/07/21/postfile/","text":"使用第三方库使用from requests_toolbelt.multipart.encoder import MultipartEncoder。 12345678910import requestsfrom requests_toolbelt.multipart.encoder import MultipartEncoderm = MultipartEncoder( fields=&#123;'field0': 'value', 'field1': 'value', 'field2': ('filename', open('file.py', 'rb'), 'text/plain')&#125; )r = requests.post('http://httpbin.org/post', data=m, headers=&#123;'Content-Type': m.content_type&#125;) 其中field0和field1是上传文件时所带的参数。field2为上传的文件的字段名，filename为临时文件名， pen(&#39;file.py&#39;, &#39;rb&#39;)为上传文件的二进制数据。text/plain为上传文件格式。 不使用第三方库模拟上传文件的二进制流。 格式如下： 1---------------------------7e11719201b4 12345678910111213141516171819202122232425262728293031323334353637383940post_data = paramsboundary = '----------%s' % hex(int(time.time() * 1000))# boundary = '---------------------------7e11719201b4'tmp_data = []tmp_data.append('--%s' % boundary)# 处理params参数部分for f in post_data.keys(): tmp_data.append('Content-Disposition: form-data; name=\"%s\"\\r\\n' % f) if isinstance(post_data.get(f), str): tmp_data.append(post_data.get(f)) elif isinstance(post_data.get(f), int): tmp_data.append(str(post_data.get(f))) elif isinstance(post_data.get(f), dict): tmp_data.append(json.dumps(post_data.get(f))) else: tmp_data.append('') tmp_data.append('--%s' % boundary)# 根据filetype生成临时文件名tmp_name = getContentType(contenttype=filetype)filename = str(uuid.uuid1()) + \".\" + tmp_nametmp_data.append('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (filefieldname, filename))tmp_data.append('Content-Type: %s\\r\\n' % filetype)# print '\\r\\n'.join(tmp_data)tmp_data.append(filebody)tmp_data.append('--%s--\\r\\n' % boundary)# 将post_data转换成bytes类型t_list = []b_index = -1for tmp_ in tmp_data: if not isinstance(tmp_, bytes): t_list.append(tmp_) b_index += 1post_data = '\\r\\n'.join(tmp_data[:b_index]).encode('utf8') + '\\r\\n'.encode('utf8') + tmp_data[b_index] + '\\r\\n'.encode('utf8') + '\\r\\n'.join(tmp_data[b_index+1:]).encode('utf8')","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"}]},{"title":"【软技能】提高生产力（四）","date":"2019-07-17T12:37:15.000Z","path":"2019/07/17/softskills4/","text":"本文笔记范围为书中的第36、37、38章。 提高专注度专注不是一个“即插即用”的开关，它有着自己的冲量。 在开始一项任务前，确保你已经做好一切可以让自己免受干扰的措施，不管是内部干扰还是外部干扰。 当你准备好开工时，要用自己的意志力将注意力保持在手头的任务上。起初这种专注是被迫的，但是随着冲量的建立，推动你进入专注状态。你的目标时熬过10分钟，如果你能撑过10分钟，那么你就有足够的冲量继续保持专注。在这种情况下，即便是轻微的干扰也不大可能打破你的专注。简言之，刚开始强迫自己保持10分钟的专注状态，之后就很容易保持专注状态。 生产力提高计划 任务拆分 将手头项目拆分成一个个可以在2小时内完成的小任务，再去完成小任务。 从大到小制定计划 定计划的顺序是：年度计划-&gt;季度计划-&gt;月计划-&gt;周计划-&gt;日计划 番茄工作法基本思路你规划出打算一天内完成的工作，然后设置一个时长为25分钟的定时器。去完成计划中的一项任务。在这25分钟内，你只专注于这一项任务。屏蔽掉一切干扰项。在25分钟结束后，设置一个5分分钟的定时器，休息一下。而这30分钟，称为一个“番茄钟”。 困扰可能你长期一直被这个问题所困扰：总为自己没有做更多的事情而感到内疚。这与一天完成了多少工作无关，就好像永远不能放松似的。总觉得自己应该继续做事，以至于坐下来玩游戏时也都无法享受其中，觉得那是在浪费时间。 这个问题的根源在于：你无法准确地评估每天自己到底完成了多少任务，也没为自己每天到底要完成多少任务设定明确的目标。你试图为自己列出一份每日任务清单来解决这一问题，这看似是个好主意。可当你某些任务没有在规定时间内完成，你将备受打击。即使自己竭尽全力可还是觉得自己很失败。 有效利用番茄钟我们不一定能够控制完成一项任务到底需要多长时间。但我们可以控制自己在这一天中愿意为某项任务花多少时间 搞清楚自己每周内能完成多少个番茄钟，每周又需要完成多少任务。从而为任务设置优先级。通过计算自己完成的番茄钟的数量，可以确切的知道自己一周完成了多少任务，也就不会觉得自己没完成足够的任务。如果你没能完成给自己设定的任务，但却用完了足够数量的番茄钟。那么问题就不在于工作量是否饱和。而在于给某项任务的优先级是否正确。 每周你只有这么多番茄钟可以分配的时候，你就会小心使用这些番茄钟。使用番茄钟之前，你可能会幻想者自己可以在一周内完成超出自己实际能力范围的许多工作，高估自己。但是，开始使用番茄工作法后，就能准确的知道自己一周工作了多长时间，也知道自己完成了多少个番茄钟。 这样你的生活就大有变化，当你完成了当天的任务后，就可以尽情的享受自由时光。即使玩游戏，也不会觉得愧疚。因为你已经努力工作了一整天。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]},{"title":"【软技能】学会自我营销（三）","date":"2019-07-10T14:10:10.000Z","path":"2019/07/10/softskills3/","text":"本文笔记范围为书中的第19、20、21章。 什么是自我营销“自我营销”就是把希望得到你提供的产品或服务的人和你自己连接起来。 成功的自我营销的关键在于：为他人提供所需的价值。 其实，你每时每刻都在营销自己。当你试图说服他人接受你的想法时，本质上，就是在把自己的想法推销给他人。 1.自我营销重要吗？非常重要。在生活中经常看到酒吧的驻唱歌手的演唱水平丝毫不亚于原唱的艺术家们。但他们却一直默默无闻。仅仅拥有才华时不够的，伟大的音乐家和超级巨星之间的差距在于自我营销。 自我营销越好，你的才华才能表现的淋漓尽致。 2.我不是专家，没什么可营销的不是专家并不影响你的自我营销。发掘你的闪光点，你一定懂得世界上90%的人不懂的事情。即便是“菜鸟”、“业余爱好者”的身份也有其优势所在——很多人喜欢向只比自己稍微优秀一点的人学习，因为这些人是可望而又可及的。 自我营销要从打造自己的个人品牌开始做起。 “无处不在”原则：无论你身在何处都要营销。无论何时都要让你的目标受众轻轻一扫就有机会看到你。 3. 作为一名程序员该如何自我营销从经营自己的博客开始。持之以恒的坚持，随着时间的推移，你写的每一篇博客，都有助于营销自己，提升个人品牌的认知度。逐渐拥有自己的追随者。 如果你还没有属于自己的博客，不如开通一个博客从现在开始吧。种一棵树最好的时间是在十年前，其次就是现在。 打造引人注目的品牌品牌不只是商标，而是对产品或服务的一整套预期。关键在于品牌带给用户的感受，是用户与品牌互动的预期。 想想，当你走进一家星巴克的时候，你希望看到什么？听到了什么？你期望的室内陈设和家具又是怎样的？而你的感觉又如何？你对他们的饮品的期待又是什么。 打造一个品牌的四要素 品牌所要传递的信息 这是一个品牌最重要的，在创建一个品牌时，弄清楚你的品牌是干什么的？你是干什么的？比如：你主张做一个Simple Programmer，那么你就要围绕“化繁为简”，将复杂的概念拆解开，转化为方便大家理解的简单概念。 品牌的视觉符号 一个品牌需要一个能够代表品牌的有辨识度的视觉符号。一套能代表品牌的视觉符号，能加速品牌的传播。 品牌的一致性品牌需要一致性，在不同平台传播的信息要一致。一个品牌的一致性越强，越容易被用户关注，也越容易被记住。 品牌的曝光率 品牌的核心在于建立一套预期，当人们看到你的品牌标识或听到你的名字时，就会想到你是谁，你代表着审核么。提高品牌的曝光率，加深人们对品牌的印象。 打造一个成功的博客创建博客你可以使用Wordpress这样的免费博客，也可以将博客托管在Github上，甚至可以在自己的vps服务器上，搭建自己的博客。采用哪种方式都可以。但是，在使用免费的托管服务时，需要注意：务必注册自己的域名。即使你需要为它支付额外的费用。 Google、百度等搜索引擎给指定网页和域名进行“网页排名”时，主要依据有多少网站链接到该域名。如果以后准备迁移博客时，可以将网页排名一起带走。所以推荐在一开始时就绑定自己的域名。 写博客写博客贵在持之以恒。建议每周至少1篇的速度更新博客。关注更新速度的同时，更要重视博客内容的质量，质量越高，别人引用数就越多，网站排名就越靠前，曝光率也就越高。 持之以恒地坚持写作，坚持不懈的产出高品质的内容。做到这两点，基本就算成功了。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]},{"title":"爬虫-清除字符串中的\\xa0","date":"2019-07-10T13:54:42.000Z","path":"2019/07/10/stringxa0/","text":"爬取到的字符串为：s = &#39;性\\xa0\\xa0\\xa0\\xa0别&#39;，要去掉中间的\\xa0。 1. \\xa0为何物\\xa0 是不间断空白符 &amp;nbsp; 2. 尝试 s.replace(‘ ‘, ‘’) ——失败 s.strip() ——失败 s.replace(u’\\xa0’, u’’) ——失败 3. 解决方法12345s = '性\\xa0\\xa0\\xa0\\xa0别'sex = ''.join(s.split())## 输出性别 4. 总结&#39;&#39;.join(s.split())不仅适用于有\\xa0的字符串，也适用于正常的字符。 因此，可以总结出格式化字符串的方法。 12345678def format_string(s):'''格式化字符串可处理常见的字符串问题如：1. 带'：'和':''2. 字符串任何地方带多余空格''' return ''.join(s.strip().replace('：', '').replace(':', '').split()) 12345678# 示例&gt;&gt;&gt; s = u'ab\\xa0c: \\t\\n'&gt;&gt;&gt; s'ab\\xa0c: \\t\\n'&gt;&gt;&gt; print(s)ab c: &gt;&gt;&gt; format_string(s)'abc'","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"}]},{"title":"验证码小坑记（一）：验证码在新的页面打开是乱码","date":"2019-07-08T12:17:05.000Z","path":"2019/07/08/spider-problem1/","text":"背景在最近的爬虫项目中遇到了一个原来没遇到的问题。在登陆页面中验证码能正常显示，把验证码链接在新的标签页中打开就变成了乱码。如下图： 登录页面的正常情况 新标签页中图片的显示情况 分析1. 抓验证码的响应数据包打开开发者工具，抓验证码的包，发现返回的类型是text/html。 mark 它的preview如下： mark 可以看到显示乱码。 2. 对比其他能正常打开的验证码响应数据包 mark 从上图可以看到，可以正常打开图片的响应数据包的Content—Type是image/jpg。而显示错的Content—Type是text/html。这仅有的差别，就是问题的症结所在。 原因浏览器在获取到这种Content-Type是text/html的文件时会自动调用html的解析器对文件进行相应的处理。因为该文件类型实际并不是文本类型，却按照文本类型去处理。所以验证码图片会显示乱码。 解决办法那么，这种情况下，我们如何获取到正确的验证码图片呢？ 其实，和正常下载验证码图片的方式一样。记得保存为图片格式就好。 此处又一小坑： 当发现下载下来的图片还是无法打开时，请记得在请求图片链接时带上User-Agent。 以上，就是最近遇到的小坑。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://mrleecn.cn/tags/验证码识别/"}]},{"title":"记一次七牛图床测试域名到期后的折腾过程","date":"2019-06-22T03:38:14.000Z","path":"2019/06/22/qiniutuchuang/","text":"背景上个月开始在Github Page上搭建博客，并绑定了自己的域名。 为了在博客中插入图片，选择了七牛图床来存储需要插入的图片。七牛图床提供测试域名，方便用户快速上手。但是测试域名有效期只有30天，30天过后测试域名被收回，原来博客中的图片将无法显示。测试域名即将到期，七牛云一直发邮件提醒，但都直接无视而过。直到今天。。。。 登上博客发现所有的图片都无法显示。这才想起了七牛云一直的邮件提醒，紧接着就开始了一系列的折腾。 折腾流程登录七牛云，发现如需继续使用七牛图床，需要绑定一个完成备案的域名，还需要将域名解析到 指定的域名记录上。 绑定一个完成备案的域名没问题呀，本身博客的域名就已经完成了备案，这个好说。 紧接着还要将域名解析到指定的域名记录。这下就麻烦了。。。因为，我的博客采用双站同步的方式，www.mrleecn.cn域名已经解析到了腾讯开发者平台。 mark 在我的认知中，一个域名只能绑定一个主机。这下怎么办，难道还要为了图床，重新买一个域名然后再备案吗？显然不会因为一个图床在买一个域名的。那么只能继续查资料解决这个问题了。 发现可以不需要重新购买域名，只需要将原来域名的二级域名解析到它指定的域名记录上即可。 1.选择二级域名，并重新绑定我选择abc.mrleecn.cn（可随意指定，只需要域名解析时统一就好）作为我的二级域名。 于是将所选的二级域名重新绑定到七牛的图床上。如下： mark 绑定完成需要等待10分钟左右来生效。稍等一会，待生效后再进行下一步操作。 2.根据要求，域名解析根据七牛云帮助文档，找到我们刚才绑定的二级域名域名对应的CNAME值。 然后打开我们的域名厂商的网站进行域名解析，以腾讯云为例：添加一条如下的解析记录： mark 3.修改博客中对应图片的外链地址修改原来图片外链地址，将原域名中的临时域名部分，修改为新的二级域名。如下图所示： mark","tags":[{"name":"博客","slug":"博客","permalink":"https://mrleecn.cn/tags/博客/"}]},{"title":"win10 1809 安装MongoDB4 流程及遇到的错误","date":"2019-06-16T01:55:15.000Z","path":"2019/06/16/setupMongoDB/","text":"1. 下载安装MongoDB，下载地址 mark mark mark mark mark 此处先忽略，问题后面解决。 到此，MongoDB算是安装完成了。 2. 修改配置下面这是安装完成的目录结构： mark 1. 指定存放数据日志的目录可以采用上图中的data、log分别存储数据和日志。此处我选择自己指定目录。 数据目录： D:\\MongoDB\\data\\db（需要自己建立） 日志文件：D:\\MongoDB\\log\\mongo.log 2. 启动MongoDB以管理员身份进入到D:\\MongoDB\\bin\\目录，启动MongoDB：.\\mongod --dbpath D:\\MongoDB\\data\\db，然后在浏览器中输入127.0.0.1:27017查看状态。出现下图表示MongoDB启动成功。 mark 3. 配置本地Windows服务 修改D:\\MongoDB\\bin\\mongod.cfg文件（推荐使用Notepad编辑） 需要修改的地方有： mark 开启MongoDB服务 mark 在服务中找到MongoDB mark 右键启动该服务。 3. 开机自启还是启动管理员shell，输入net start MongoDB mark 4、常见问题及解决方法1、使用net start MongoDB命令报错——服务没有响应控制功能问题原因：MongoDB服务没启动，配置文件错误 mark 右键查看属性 mark 我们可以看到MongoDB默认的配置文件D:\\MongoDB\\bin\\mongod.cfg，打开配置文件，注释掉最后一行的mp:，重启启动服务即可解决问题。 mark","tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://mrleecn.cn/tags/软件安装/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://mrleecn.cn/tags/MongoDB/"}]},{"title":"字典与集合","date":"2019-06-01T01:57:55.000Z","path":"2019/06/01/dictandset/","text":"本文为极客时间 Python核心技术与实战 专栏的学习笔记 字典在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。 相比列表和元组，字典性能更优，可以在常数时间复杂度O(1)内完成查找、添加、删除操作。 常用创建方法123456&gt;&gt;&gt; d1 = &#123;'name': 'Json', 'age': 20, 'gender': 'male'&#125;&gt;&gt;&gt; d2 = dict( &#123;'name': 'Json', 'age': 20, 'gender': 'male'&#125;)&gt;&gt;&gt; d3 = dict([('name', 'Json'),('age', 20),('gender','male')])&gt;&gt;&gt; d4 = dict(name='Json', age=20, gender='male')&gt;&gt;&gt; d1 == d2 == d3 == d4True 索引使用dict[key]格式索引，如果不存在，会抛出KeyError异常。 123456&gt;&gt;&gt; d1['name']'Json'&gt;&gt;&gt; d1['location']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'location' 使用get(key, default)方法不会抛出异常，此外当该键不存在时，可以指定返回的默认值。 123456&gt;&gt;&gt; d1.get('name')'Json'&gt;&gt;&gt; d1.get('location')&gt;&gt;&gt; d1.get('location', None)None 判断某元素是否是字典的键： 12345678&gt;&gt;&gt; 'name' in d1 # 同d1.keys()等价True&gt;&gt;&gt; 'name' in d1.keys() True&gt;&gt;&gt; 'Json' in d1 False&gt;&gt;&gt; 'Json' in d1.values()True 添加1234&gt;&gt;&gt; d = &#123;'name': 'jason', 'age': 20&#125;&gt;&gt;&gt; d['gender'] = 'male'&gt;&gt;&gt; d&#123;'name': 'jason', 'age': 20, 'gender': 'male'&#125; 删除1234&gt;&gt;&gt; d.pop('gender')'male'&gt;&gt;&gt; d&#123;'name': 'jason', 'age': 20&#125; 排序根据键排序 123456&gt;&gt;&gt; d = &#123;'b': 1, 'v': 20, 'a': 17&#125;&gt;&gt;&gt; d_sorted_by_key = sorted(d.items(), key=lambda x: x[0])&gt;&gt;&gt; d_sorted_by_key[('a', 17), ('b', 1), ('v', 20)]&gt;&gt;&gt; d&#123;'b': 1, 'v': 20, 'a': 17&#125; 根据值排序 123&gt;&gt;&gt; d_sorted_by_value = sorted(d.items(), key = lambda x: x[1])&gt;&gt;&gt; d_sorted_by_value[('b', 1), ('a', 17), ('v', 20)] 性能分析举例：有1000万件产品，产品信息包括：产品ID、价格。现在需求是：给定某件产品的ID，找出其价格： 1.用列表来存储数据 存储结构如下： 12345products = [ (143121312, 100), (432314553, 30), (32421912367, 150) ] 那么查找需要遍历整个列表，时间复杂度为O(n)。即使先对列表排序，然后二分查找，也会需要O(logn)的时间复杂度，并且排序还需要O(nlogn)的时间。 2. 用字典存储数据 存储结构如下： 12345products = &#123; '143121312': 100, '432314553': 30, '32421912367': 150&#125; 因为字典内部结构是一张哈希表，所以可以在O(1)的时间复杂度内完成查找。 3. 效率对比 123456789101112131415161718192021222324252627282930313233343536import timeimport numpydef find_product_price_list(products, product_id): for id, price in products: if id == product_id: return price return Nonedef find_product_price_dict(products, product_id): for id in products.keys(): if id == product_id: return products_dict[id] return Noner = numpy.random.randint(0,10000000,10000000) # 生成10000000个随机数id = [str(x) for x in r]price = [x for x in range(20000000, 30000000)]products_list = list(zip(id, price))products_dict = dict(zip(id, price))# 添加新元素products_list.append(('111111111', 300)) # 追加到列表末尾products_dict['111111111'] = 300start_using_dict = time.perf_counter()find_product_price_dict(products_dict, '111111111')end_using_dict = time.perf_counter()print('time elapse using dict: &#123;&#125;'.format(end_using_dict - start_using_dict))start_using_list = time.perf_counter()find_product_price_list(products_dict, '111111111')end_using_list = time.perf_counter()print('time elapse using list: &#123;&#125;'.format(end_using_list - start_using_list))# ===========运行结果============time elapse using dict: 0.1983588489999999time elapse using list: 0.41368435999999953 集合而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。 常用创建方法1234&gt;&gt;&gt; s1 = &#123;1,2,3&#125;&gt;&gt;&gt; s2 = set([1,2,3])&gt;&gt;&gt; s1 == s2True 索引集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。 进行如下操作，Python会抛出TypeError异常。 1234&gt;&gt;&gt; s1[0]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'set' object is not subscriptable 只能判断某元素是否在集合中： 1234&gt;&gt;&gt; 1 in s1True&gt;&gt;&gt; 10 in s1False 添加1234&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 删除123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; 注意：由于集合是无序的，所以无法确定pop()方法会删除哪个元素，所以谨慎使用。一般删除操作采用remove()即可。 排序123&gt;&gt;&gt; s = &#123;2,4,546,34&#125;&gt;&gt;&gt; sorted(s)[2, 4, 34, 546] 集合运算常用集合运算 语法 操作 说明 set(list1) \\ set(list2) union 包含 list1 和 list2 所有数据的新集合 set(list1) &amp; set(list2) intersection 包含 list1 和 list2 中共同元素的新集合 set(list1) - set(list2) difference 在 list1 中出现但不在 list2 中出现的元素的集合 性能分析还是以上面那个例子为例，现在要求计算出有多少种价格。为了节省时间，我们把产品数量降低到10万。 查找效率1. 用列表存储数据 需要两层循环。那么，在最差情况下，需要 O(n^2) 的时间复杂度。 2. 用集合存储数据 由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度，那么，总的时间复杂度就只有 O(n)。 3. 效率对比 12345678910111213141516171819202122232425262728293031323334353637import timeimport numpydef find_unique_price_set(products): unique_price_set = set() for _, price in products: unique_price_set.add(price) return len(unique_price_set)def find_unique_price_list(products): unique_price_list = [] for _, price in products: # A if price not in unique_price_list: #B unique_price_list.append(price) return len(unique_price_list)r = numpy.random.randint(0,1000000,100000) # 生成100000个随机数id = [str(x) for x in r]price = [x for x in range(200000, 300000)]products = list(zip(id, price))start_using_set = time.perf_counter()find_unique_price_set(products)end_using_set = time.perf_counter()print('time elapse using set: &#123;&#125;'.format(end_using_set - start_using_set))start_using_list = time.perf_counter()find_unique_price_list(products)end_using_list = time.perf_counter()print('time elapse using list: &#123;&#125;'.format(end_using_list - start_using_list))# ===========运行结果============time elapse using set: 0.00985934799999999time elapse using list: 65.528253501 可以看出，仅10万数据，差距就已经很明显了。 交集、并集、差集运算以求交集为例： 12345678910111213141516171819202122232425262728293031import timelist_a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 34, 53, 42, 44]list_b = [2, 4, 6, 9, 23]intersection = []# 列表做交集start_using_list = time.perf_counter()for a in list_a: for b in list_b: if a == b: intersection.append(a)end_using_list = time.perf_counter()print(intersection)print('time: &#123;&#125;'.format(end_using_list - start_using_list))# 集合做交集start_using_list = time.perf_counter()intersection = list(set(list_a) &amp; set(list_b))end_using_list = time.perf_counter()print(intersection)print('time: &#123;&#125;'.format(end_using_list - start_using_list))# ===========运行结果============[2, 4, 6, 9]time: 9.622000000000797e-06[9, 2, 4, 6]time: 4.169000000001782e-06 因为篇幅有限。字典和集合的工作原理，请看下篇博客。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"极客时间","slug":"极客时间","permalink":"https://mrleecn.cn/tags/极客时间/"}]},{"title":"对Python中列表及元组运行机制的理解","date":"2019-05-30T13:03:17.000Z","path":"2019/05/30/listandtuple/","text":"本文为极客时间 Python核心技术与实战 专栏的学习笔记 相同点 Python 中的列表和元组都支持负数索引 列表和元组都支持切片操作 列表和元组都可以随意嵌套 两者也可以通过 list() 和 tuple() 函数相互转换： 12345list((1, 2, 3))[1, 2, 3]tuple([1, 2, 3])(1, 2, 3) 列表和元组常用的内置函数：123456789101112131415161718192021l = [3, 2, 3, 7, 8, 1]l.count(3) 2l.index(7)3l.reverse()l[1, 8, 7, 3, 2, 3]l.sort()l[1, 2, 3, 3, 7, 8]tup = (3, 2, 3, 7, 8, 1)tup.count(3)2tup.index(7)3list(reversed(tup))[1, 8, 7, 3, 2, 3]sorted(tup)[1, 2, 3, 3, 7, 8] 解释如下： count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。 不同点 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 不能给元组增删元素 12345tup = (1, 2, 3, 4)tup[3] = 40Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment 如果需要对已有元组进行“改变”，就必须开辟新的内存空间，创建新元组。 代码示例如下： 123456789tup = (1, 2, 3, 4)new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值new _tup(1, 2, 3, 4, 5)l = [1, 2, 3, 4]l.append(5) # 添加元素 5 到原列表的末尾l[1, 2, 3, 4, 5] 列表和元组存储方式的差异1. 存储差异1234567&gt;&gt;&gt; l = [1, 2, 3]&gt;&gt;&gt; l.__sizeof__()64&gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; tup.__sizeof__()48 可以看到，对列表和元组，我们放置了相同的元素，但是元组的存储空间，却比列表要少 16 字节。这是为什么呢？ 事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。 1234567&gt;&gt;&gt; l = []&gt;&gt;&gt; l.__sizeof__() // 空列表的存储空间为 40 字节40&gt;&gt;&gt; t = () // 空元组的存储空间为 24 字节&gt;&gt;&gt; t.__sizeof__()24 继续在列表中添加元素，观察列表内存空间的变化： 123456789101112131415l.append(1)l.__sizeof__() 72 // 加入了元素 1 之后，列表为其分配了可以存储 4 个元素的空间 (72 - 40)/8 = 4l.append(2) l.__sizeof__()72 // 由于之前分配了空间，所以加入元素 2，列表空间不变l.append(3)l.__sizeof__() 72 // 同上l.append(4)l.__sizeof__() 72 // 同上l.append(5)l.__sizeof__() 104 // 加入元素 5 之后，列表的空间不足，所以又额外分配了可以存储 4 个元素的空间 上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。 但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。 在数据量非常庞大时，列表和元组之间存储空间上的差距差别会非常明显，所以选择合适的数据结构很关键。 2. 性能差异通过上面的例子，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。 另外，Python在后台会对静态数据做一些资源缓存，由于垃圾回收机制的存在，一些变量不被使用就会被Python收回它们所占的内存。 对于元组来说，如果占用空间并不大，Python会暂时缓存这部分，下次创建同等大小的内存就不必再去向操作系统申请，大大加快了程序运行速度。 总结存储数据和数量不变时，用元祖。数据和数量可变时，用列表。 初始化，元组快 索引操作，二者速度差不多 增加、删除，列表更优","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"极客时间","slug":"极客时间","permalink":"https://mrleecn.cn/tags/极客时间/"}]},{"title":"【软技能】攀登晋升阶梯（二）","date":"2019-05-27T14:10:10.000Z","path":"2019/05/27/softskills2/","text":"本文笔记范围为书中的第9章。 攀登晋升阶梯关于晋升，书中提到的几条建议： 承担责任 引人注目 自学 成为问题的解决者 下面分别对这几条建议进行阐述。 承担责任在任何公司能让你脱颖而出的最重要的法宝就是承担更多的责任。金钱总是追随着责任。有任何机会去承担更多责任时，请承担起来！ 没有人愿意涉足的领域是搜寻机会最好的地方。因为没有人愿意涉足，所以无需去抢，这些就成为你日益强大的帝国的领地。如果你能把沼泽变为良田，你也就展现了自己的价值。 另一种承担责任的方式是成为团队中其他人的导师。自愿帮助新人加速成长。通过介入和解决别人的问题，不仅可以学到更多自己专业以外的知识，而且随着时间推移，你在团队中逐步树立“及时雨”的名声。这样的声誉可能会让你成为团队领导或其他管理职位。 引人注目如果找不到方法让你的老板和高层管理员知道你在做什么，那你的努力都是徒劳。 文中作者引起老板注意的方法： 每当开始新工作时，我（该书作者）所做的第一件事就是记日志，记录每天的时间都花在什么地方，完成了哪些工作。将这些信息汇总成周总结，每个周五发给上级领导。这份周报确保我每周都会被上级领导注意到。 其他方式： 提供演讲或培训——选择一个对你团队有用的话题。 发表意见——只哟啊在会议上就这么做，或者只要你能得到机会就这么做。 保证”曝光度“——定期与老板会面，确保你经常被注意到 自学自学能让升职加薪变得容易，因为你可以很清楚地表明：现在的自己比之前更有价值。 你应该不断学习新东西，提升自己的技能。报名参加培训课程，或者考相应的资质证书，都能表明你致力于不断提升自己。你掌握的东西越多，随之而来的机会就越多。 分享自己学到的东西。你可以通过演讲的方式，分享自己的知识，也可以创建自己的博客、为杂志写文章或写书。外部曝光有助于你建立自己在该领域的权威地位，也让你看起来对公司更有价值。 成为问题的解决者如果你能解决别人无法解决或不愿解决的问题，无论在哪家公司，你都能轻而易举地成为最有价值的人。 有时候只要意识到自己的工作毫无前途，就需要寻找更好的机会。无论什么原因，你可能都需要换工作。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]},{"title":"【软技能】从非同凡响开始（一）","date":"2019-05-25T16:18:10.000Z","path":"2019/05/26/softskills1/","text":"《软技能 代码之外的生存指南》读书笔记——职业篇（一） 说明本文是《软技能 代码之外的生存指南》读书笔记的第一篇，通过记录读书笔记的方式，来复盘书中的一些自己有所感悟的内容。 本文笔记范围为书中的第2、3、4章。 一、从非同凡响开始：绝不要做他人都在做的事转变思维时代已经变了，尽管在你的职业生涯的某个特定时间段里，可能在为某个公司打工，但不要让那个特定的角色固化你和你的职业生涯。尝试转变心态，把自己当作一个企业去思考，从被一纸“卖身契”束缚住的仆人转变为一名拥有自己生意的商人，积极主动地管理自己的职业生涯。 如何像企业一样思考从思考企业的构成开始，大多数成功企业都需要以下几样东西： 一个产品或服务 不提供商品的企业是无法赚钱的，你有什么可卖？你的产品或服务是什么？ 关注市场营销 想要赚钱，就必须能让潜在客户了解该产品或服务。产品营销做得越好，服务定价就越高，也越有机会吸引更多的潜在客户。 想方设法提升你的服务 服务质量与企业的发展成正相关。 思考产品或服务的具体方向 你可以专注为那一特定类型的客户或行业提供特定的服务。 成为行业专家 集中精力成为一名专家，专门为某一特定类型的客户提供专业的整体服务（只有你真正专注于一类客户，才能找到非常好的工作）。 采取行动 想象一下：有一家企业，拥有某个 产品或服务。他们将如何推广这一产品或服务从而做到卓尔不凡？ 如果只用一句话来描述你的能为潜在雇主或客户提供怎样的特定服务，这句话是什么？ 二、思考未来：你的目标是什么如何设定目标树立一个大目标起初阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。 因为很难清晰地界定远期可能发生的事情，所以大目标： 不够具体，只需要具体到能给你提供清晰的方向 如同航海一般，刚开始，我们没必要立刻知道要驶向的港口的精确经纬度，只需要朝着目标港口航向前进。随着离目标越来越近，就能获得更多数据，不断修正航线，最终到达目标港口。 不需要那么具体，但必须足够清晰，能够让你知道自己是在向它靠近还是远离 建立小目标如果你可以驱动小目标逐渐靠近你的大目标，那么最终你一定功能到达目的地。 设定大小不同的目标，确保你向着自己的大目标前进，这一点非常重要。 合理小目标的好处： 较小的目标可以保证自己航行在正确的轨道上，不会偏离最终大目标。 达成小目标，让我们感觉良好，帮助我们继续前进。 较小的目标不像大目标那样令人望而生畏。 追踪你的目标定期核对自己目标，反思自己在短期和长期取得的成果是大有裨益的，你能够弄清楚自己是否取得了合理的进展，或是是否要进行某些调整。 采取行动 为你的职业生涯设置至少一个大目标。 将大目标分解成相应的若干小目标，例如： 月目标 周目标 每日目标 把你的大目标卸载自己每天必经之地，每日三省吾身——我在追求什么。 三、人际交往能力：远比你想象的重要人际交往的你需要知道的重要原则1. 每个人都希望感到自己很重要以自己为核心，每个人都希望自己很重要。这是人类最深邃、最致命的欲望之一。也是社会和生活中取得伟大成就的主要动机。 如果你希望人们接受你的想法，并认可其中价值，首先你最好主动给他人同样的礼遇。如果你不能保全他人的自醉，那你永远也不可能赢得他的心。 2. 永远不要批评“批评”是一项很少能够达成你期望结果的工具。 奖励积极行为要比惩罚消极行为有效得多。如果你想激励团队鼓舞士气，那就用表扬替代批评吧。 3. 换位思考停用”我”和“我想要什么”来思考，开始思考对他人而言什么才最重要，什么才是他们需要的。 从对方的心态出发提建议。 4. 避免争吵如果你认为“该怎么做某事”与他人产生分歧，那么在多数情况下，你最好能确定分歧点是否值得你拼命维护。小事情上，任何放弃立场或承认错误的机会对你而言可能没什么大不了的，但对他人却可能是举足轻重的，这么做不仅能为你赢得不可估量的尊重。也能为你的未来积蓄财富，形势逆转时即可兑换使用。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]},{"title":"字符带旋转的验证码识别思路（Python）","date":"2019-05-22T08:26:14.000Z","path":"2019/05/22/yzm-thinking/","text":"背景介绍为了实现某网站的模拟登录，需要对验证码进行识别，该验证码除了有背景的干扰图案之外，字符也有不同角度的倾斜，高度也不统一，如下图所示： mark mark 面临的问题经过各方查找，网上大多数验证码识别教程都是字符规整且直立的验证码，方法也都大同小异。 字符粘连在一起就切片，自己做验证码库进行识别； 没有粘连在一起，就通过机器学习、神经网络等方法进行识别。 对于没有学习过机器学习、神经网络的我，不能短时间上手。 解决思路于是，想到了采用切片做库的识别思路。 第一步：获取大量验证码图片下载大量的验证码（视情况而定，我选择了300张），为后面验证码切片做库做准备。图片最好保存为gif格式。 第二步：验证码图片预处理对第一步下载的全部验证码图片进行灰度化、二值化。 为保证经过预处理后的验证码图片效果，此处需要对二值化的阈值，进行仔细调整。 预处理代码如下： 1234567891011121314151617181920from PIL import Image def preprocessing(yzm_path='yzm.gif', new_yzm_path='yzm.gif'): ''' 验证码预处理，灰度化，二值化 :param captcha_path: 验证码图片路径 :param new_captcha_path: 经过预处理后验证码图片保存路径 ''' image = Image.open(yzm_path) # 灰度化 image = image.convert('L') # 二值化 table = [] for i in range(256): if i &lt; self.threshold: table.append(0) else: table.append(1) image = image.point(table, '1') image.save(new_yzm_path) 经过预处理后的图片如下图所示： mark 第三步： 验证码图片切片因为每个字符高度不统一，因此切片时除了要将每个字符单独切出来外，还要将字符四周多余空白行（列）也要去除。 这里将会出现一个问题，对于字符i、j在某些倾斜角度时，无法保证i、j切片的完整性。这里，我们选择性放弃i、j首部的点，而只留下尾部（因为首部的点相对于尾部，不具有辨识度）。 将全部经过预处理后的验证码图片进行切片操作。切片方法，请移步到我的另一篇博客验证码高效切片方法（Python）。 第四步：手动制作原始验证码库这一步最为繁琐。将第三步切片后的字符图片进行分类。可以借助打码平台帮你完成，也可通过自己手动对字符图片进行分类。制作原始的验证码库（我的分类方法：在一个空目录下建立以0-9、a-z命名的36个目录，将对应字符图片放到对应目录中）。 我的原始验证码库达到1500张字符图片。经测试识别率在70%。 第五步：验证码识别这一步可以参考Python计算图片之间的相似度 以下是我修改后的代码： 12345678910111213141516171819202122232425def get_similarity_degree(vector1, vector2): ''' 计算两图片的相似度 :param vector1: 图片1的向量 :param vector2: 图片2的向量 :return: 相似度 ''' # dot返回的是点积，对二维数组（矩阵）进行计算 res = dot(vector1, vector2) return resdef get_img_vectors(image): ''' 计算图片的余弦距离 :param image: Image图片对象 :return: 图片的向量 ''' image = image.resize(compare_img_size, Image.ANTIALIAS) # compare_img_size=(30, 30) vector = [] for pixel_tuple in image.getdata(): vector.append(average(pixel_tuple)) # linalg=linear（线性）+algebra（代数），norm则表示范数 # 求图片的范数 norm = linalg.norm(vector, 2) return vector / norm 第六步：实现验证码库自动更新进行大量的模拟登录（使用自己的验证码库做识别），当模拟登录成功且验证码字符与验证码库内字符切片相似度小于某个值（我选择的95%）时，将改验证码字符加入到验证码库中。 关键代码如下： 123456789101112131415 def yzmstore_update(self): ''' 将正确的验证码切片加入库中，以时间戳命名 :param result: 验证码字符串 :return: '''# self.yzmstore_waitupdate_img = ['./img_crop/z/split_0.gif', ....] letters_list = list(i[1].split('/')[-2] for i in self.yzmstore_waitupdate_img) # 获取验证码对应字符 ['z'] for i in range(len(letters_list)): new_yzm_dir = '&#123;0&#125;&#123;1&#125;/'.format(self.yzmstore_rootdir, letters_list[i]) time_stamp = time.time() # 当前时间戳 time.sleep(0.1) # 等待0.1s避免时间戳一致 new_yzm_name = '&#123;0&#125;split&#123;1&#125;.gif'.format(new_yzm_dir, str(time_stamp).replace('.', '')) # 去掉时间戳中的'.' old_yzm_name = self.yzmstore_waitupdate_img[i][0] shutil.move(old_yzm_name, new_yzm_name) # 将待添加的验证码图片移动到验证码库中 经测试，当验证码库达到5000张时，识别率达到94%。 细节部分由于计算图片向量值很耗时，所以可以提前将验证码库内字符图片的向量值提前计算好，进行模拟登录时，只需计算当前验证码的向量值，然后和已经计算好的验证码库的图片的向量进行相似度比较即可（比较速度非常快：不到0.5s）。从而减少整个模拟登录的时间。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://mrleecn.cn/tags/验证码识别/"}]},{"title":"Numpy笔记","date":"2019-05-22T06:28:25.000Z","path":"2019/05/22/numpy/","text":"标准Python列表list的缺点标准的 Python 中，用列表 list 保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中list保存的是对象的指针。虽然Python中隐区了指针的概念。但是数组有指针，Python的列表list其实就是数组。这样如果我要保存一个简单的数组[0, 1, 2]，就需要有3个指针和3个整数对象。这样对于Python来说是非常不经济的，浪费内存和计算时间。 为什么用Numpy为什么要用 NumPy 数组结构而不是 Python 本身的列表 list？这是因为列表 list 的元素在系统内存中是分散存储的，而 NumPy 数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表 list 还需要对内存地址进行查找，从而节省了计算资源。 另外在内存访问模式中，缓存会直接把字节块从 RAM 加载到 CPU 寄存器中。因为数据连续的存储在内存中，NumPy 直接利用现代 CPU 的矢量化指令计算，加载寄存器中的多个连续浮点数。另外 NumPy 中的矩阵计算可以采用多线程的方式，充分利用多核 CPU 计算资源，大大提升了计算效率。 当然除了使用 NumPy 外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：避免采用隐式拷贝，而是采用就地操作的方式。举个例子，如果我想让一个数值 x 是原来的两倍，可以直接写成 x=2，而不要写成 y=x2。这样速度能快到 2 倍甚至更多。 Numpy基础NumPy 用字符编码来表示数据类型。如下表: 数据类型 字符编码 整数 i 无符号整数 u 单精度浮点数 f 双精度浮点数 d 布尔值 b 复数 D 字符串 S Unicode U Void V 创建数组12345678910111213141516import numpy as npa = np.array([1, 2, 3])b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])b[1,1]=10 # 直接修改数组元素print a.shape # 数组形状print b.shapeprint a.dtype # 数组类型print b结果：(3L,)(3L, 3L)int32[[ 1 2 3] [ 4 10 6] [ 7 8 9]] 结构数组12345678910111213141516171819202122# 自定义数组类型import numpy as nppersontype = np.dtype(&#123; &apos;names&apos;:[&apos;name&apos;, &apos;age&apos;, &apos;chinese&apos;, &apos;math&apos;, &apos;english&apos;], &apos;formats&apos;:[&apos;S32&apos;,&apos;i&apos;, &apos;i&apos;, &apos;i&apos;, &apos;f&apos;]&#125;)peoples = np.array([(&quot;ZhangFei&quot;,32,75,100, 90),(&quot;GuanYu&quot;,24,85,96,88.5), (&quot;ZhaoYun&quot;,28,85,92,96.5),(&quot;HuangZhong&quot;,29,65,85,100)], dtype=persontype)ages = peoples[:][&apos;age&apos;]chineses = peoples[:][&apos;chinese&apos;]maths = peoples[:][&apos;math&apos;]englishs = peoples[:][&apos;english&apos;]print np.mean(ages)print np.mean(chineses)print np.mean(maths)print np.mean(englishs)==================28.2577.593.2593.75 连续数组的创建np.arange 和 np.linspace 起到的作用是一样的，都是创建等差数组。这两个数组的结果 x1,x2 都是 [1 3 5 7 9]。结果相同，但是你能看出来创建的方式是不同的。12x1 = np.arange(1,11,2)x2 = np.linspace(1,9,5) 算数运算通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求n次方、取余的运算。1234567891011121314151617x1 = np.arange(1,11,2)x2 = np.linspace(1,9,5)print np.add(x1, x2) # 加print np.subtract(x1, x2) # 减print np.multiply(x1, x2) # 乘print np.divide(x1, x2) # 除print np.power(x1, x2) # n次方print np.remainder(x1, x2) # 取余==================[ 2. 6. 10. 14. 18.][0. 0. 0. 0. 0.][ 1. 9. 25. 49. 81.][1. 1. 1. 1. 1.][1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05 3.87420489e+08][0. 0. 0. 0. 0.] 统计函数 函数名 作用 注释 amax() 最大值函数 amin() 最小值函数 ptp() 最大值与最小值之差 percentile() 数组百分位数（） 百分位数的概念：第p个百分位数是这样一个值，它使得至少有p%的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值。 median() 中位数 mean() 平均数 average() 加权平均数 默认权值为1 std() 标准差 var() 方差 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import numpy as npa = np.array([[1,2,3], [4,5,6], [7,8,9]])# 最小值print np.amin(a) # 矩阵中最小元素print np.amin(a,0) # 按列计数的计数组中的最小元素print np.amin(a,1) # 按行计数的计数组中的最小元素1[1 2 3][1 4 7]===================# 最大值print np.amax(a) # 矩阵中最大元素print np.amax(a,0) # 按列计数的计数组中的最大元素print np.amax(a,1) # 按行计数的计数组中的最大元素9[7 8 9][3 6 9]===================# 最小值、最大值之差print np.ptp(a)print np.ptp(a,0)print np.ptp(a,1)8[6 6 6][2 2 2]===================# 百分位数（取值0-100）print np.percentile(a, 50) # 50表示取中位数print np.percentile(a, 50, axis=0)print np.percentile(a, 50, axis=1)5.0[4. 5. 6.][2. 5. 8.]==================# 中位数print np.median(a)print np.median(a, axis=0)print np.median(a, axis=1)5.0[4. 5. 6.][2. 5. 8.]==================# 求平均数print np.mean(a)print np.mean(a, axis=0)print np.mean(a, axis=1)5.0[4. 5. 6.][2. 5. 8.]===================# 加权平均值a = np.array([1,2,3,4])wts = np.array([1,2,3,4]) # 权重print np.average(a)print np.average(a,weights=wts)2.53.0===================# 标准差、方差a = np.array([1,2,3,4])print np.std(a)print np.var(a)1.1180339887498951.25=================== 排序1sort(a, axis=-1, kind=‘quicksort’, order=None) 默认情况下使用的是快速排序； kind 可以指定 quicksort 快速排序 mergesort 合并排序 heapsort 堆排序 axis 默认是-1，即沿着数组的最后一个轴进行排序也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。 order 字段，对于结构化的数组可以指定按照某个字段进行排序。1234567891011121314a = np.array([[4,3,2],[2,4,1]])print np.sort(a)print np.sort(a, axis=None) # 扁平化排序print np.sort(a, axis=0) print np.sort(a, axis=1) [[2 3 4] [1 2 4]][1 2 2 3 4 4][[2 3 1] [4 4 2]][[2 3 4] [1 2 4]]","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"数据处理","slug":"数据处理","permalink":"https://mrleecn.cn/tags/数据处理/"},{"name":"Numpy","slug":"Numpy","permalink":"https://mrleecn.cn/tags/Numpy/"}]},{"title":"Pandas中 Series、DataFrame","date":"2019-05-22T06:10:17.000Z","path":"2019/05/22/Pandas/","text":"Series是一个定长的字典序列。两个基本属性：index 和values 建立Series第一种方法12345678910111213141516from pandas import Series, DataFramex1 = Series([1, 2, 3, 4])x2 = Series(data=[1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])print(x1)print(x2)0 11 22 33 4dtype: int64a 1b 2c 3d 4dtype: int64 第二种方法123456789d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3, &apos;d&apos;:4&#125;x3 = Series(d)print(x3)a 1b 2c 3d 4dtype: int64 DataFrame类似于数据库表包括行索引和列索引 建立DataFrame1234567891011121314151617181920212223import pandas as pdfrom pandas import Series, DataFramedata = &#123;&apos;Chinese&apos;: [66, 95, 93, 90, 80], &apos;English&apos;: [65, 85, 92, 88, 90], &apos;Math&apos;: [30, 98, 96, 77, 90]&#125;df1 = DataFrame(data)df2 = DataFrame(data, index=[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;ZhaoYun&apos;, &apos;HuangZhong&apos;, &apos;DianWei&apos;], columns=[&apos;English&apos;, &apos;Math&apos;, &apos;Chinese&apos;])print(df1)print(df2) Chinese English Math0 66 65 301 95 85 982 93 92 963 90 88 774 80 90 90 English Math ChineseZhangFei 65 30 66GuanYu 85 98 95ZhaoYun 92 96 93HuangZhong 88 77 90DianWei 90 90 80 数据导入和导出Pandas支持直接从xlsx,csv等文件中导入数据，也可以导出到xlsx,csv等文件中。（可能少包，根据提示安装即可）12345import pandas as pdfrom pandas import Series, DataFramescore = DataFrame(pd.read_excel(&apos;data.xlsx&apos;)) # 导入score.to_excel(&apos;data1.xlsx&apos;) # 导出print score 数据清洗12data = &#123;&apos;Chinese&apos;: [66, 95, 93, 90,80],&apos;English&apos;: [65, 85, 92, 88, 90],&apos;Math&apos;: [30, 98, 96, 77, 90]&#125;df2 = DataFrame(data, index=[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;ZhaoYun&apos;, &apos;HuangZhong&apos;, &apos;DianWei&apos;], columns=[&apos;English&apos;, &apos;Math&apos;, &apos;Chinese&apos;]) 去除不必要的行或列1df2 = df2.drop(columns=[&apos;Chinese&apos;]) 重命名columns，让列名更容易识别1df2.rename(columns=&#123;&apos;Chinese&apos;: &apos;YuWen&apos;, &apos;English&apos;: &apos;Yingyu&apos;&#125;, inplace = True) 去除重复值1df = df.drop_duplicates() # 去除重复行 格式问题修改数据格式12df2[&apos;Chinese&apos;] = df2[&apos;Chinese&apos;].astype(&apos;str&apos;) df2[&apos;Chinese&apos;] = df2[&apos;Chinese&apos;].astype(np.int64) 数据间的空格123456# 删除左右两边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.strip)# 删除左边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.lstrip)# 删除右边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.rstrip) 大小写转换123456# 全部大写df2.columns = df2.columns.str.upper()# 全部小写df2.columns = df2.columns.str.lower()# 首字母大写df2.columns = df2.columns.str.title() 查找空值1234# 查看那个地方存在空值df.isnull()# 查看哪列存在空值df.isnull().any() apply()目前未用到 数据统计Pandas 和 NumPy 一样，都有常用的统计函数，如果遇到空值 NaN，会自动排除。常见统计函数： 函数 作用 count() 统计个数，空值、NaN不计算 describe() 一次性输出多个统计指标，包括：count、mean、std、min、max等 min() 最小值 max() 最大值 sum() 总和 mean() 平均值 median() 中位数 var() 方差 std() 标准差 argmin() 统计最小值的索引位置 argmax() 统计最大值的索引位置 idxmin() 统计最小值的索引值 idxmax() 统计最大值的索引值 数据表合并12df1 = DataFrame(&#123;&apos;name&apos;:[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;data1&apos;:range(5)&#125;)df2 = DataFrame(&#123;&apos;name&apos;:[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;], &apos;data2&apos;:range(5)&#125;) 指定列连接1df3 = pd.merge(df1, df2, on=&apos;name&apos;) 内连接merge的默认合并情况。1df3 = pd.merge(df1, df2, how=&apos;inner&apos;) 左连接1df3 = pd.merge(df1, df2, how=&apos;left&apos;) 右连接1df3 = pd.merge(df1, df2, how=&apos;right&apos;) 外连接1df3 = pd.merge(df1, df2, how=&apos;outer&apos;)","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://mrleecn.cn/tags/Pandas/"},{"name":"数据处理","slug":"数据处理","permalink":"https://mrleecn.cn/tags/数据处理/"}]},{"title":"验证码高效切片方法（Python）","date":"2019-05-21T11:46:14.000Z","path":"2019/05/21/image-split/","text":"说明验证码图片如下图所示： 验证码 切片完成后的效果如下图所示： 切片1 切片2 切片3 切片4 切片5 一、思路首先对图片进行预处理，请参考我的另一篇文章。然后再对验证码进行切片，切片包括： 纵向切片（去除字符左右的空白区域） 横向切片（去除字符上下的空白区域） 纵向切片从验证码图片的左端开始，依次遍历每列，寻找第一个含有黑像素的列，作为该字符切片的起始端。然后继续遍历，找到第一个不含黑像素的列，作为该字符切片的结束端（躺平的i、j只要尾部不要首部）。直到遍历完整张图片，即找到全部字符的切片位置，然后对图片进行切片，将每个字符切片保存为单独的图片。时间复杂度为O(n). 横向切片采用递归的方式。从图片中间的一行开始遍历。如果中间一行有黑色像素，表示中间一行在字符中间。由中间向两边遍历，找到字符的起始端start和结束端end。如果中间一行没有黑像素，于是分别在图片的上、下半部分继续采用递归的方式继续寻找。直到找到字符的两端（如果整张图片全为白色，则递归跳出的判断语句为start&gt;=end），然后进行切片，实现最终效果。时间复杂度为O(logn)。 二、代码实现1、纵向切片12345678910111213141516171819def deal_col(self, img_path): ''' 验证码纵向处理 :param img_path:验证码路径 :return: ''' image = Image.open(img_path) # 纵向切 letters = self.split_col(image) # 保存各个切片图片 try: for j in range(len(letters)): im_spilt = image.crop((letters[j][0], 0, letters[j][1], image.size[1])) new_path = self.img_dir + '&#123;0&#125;.gif'.format(j) im_spilt.save(new_path) self.captcha_firstsplit_paths.append(new_path) except: pass 1234567891011121314151617181920212223242526272829def split_col(self, image): ''' 寻找验证码纵向的切割边界 :param image: 验证码对象 :return: 每个字符的起始横坐标和结束横坐标的list ''' inletter = False # 标记当前列是否在字符内，False表示不在字符内，True表示在字符内 foundletter = False # 标记是否找到字符，False表示目前没找到字符，True表示已经找到字符 start = 0 end = image.size[0] letters = [] # 记录每个字符的起始坐标和结束坐标 for x in range(image.size[0]): # 按列查找 for y in range(image.size[1]): pix = image.getpixel((x, y)) if pix != 255: # 不为白色，表示进入字符 inletter = True if foundletter == False and inletter == True: # 刚进入字符，将foundletter标记为True foundletter = True start = x if foundletter == True and inletter == False: # 当前列已经出了字符，并将起始位置 foundletter = False # 将foundletter重置为False end = x if end - start &gt;= 4: # 如果字符切片宽度大于等于4像素，则记录起始终止位置； letters.append((start, end)) # 否则，认为当前切片为图片的噪点，或平躺的i、j首部（不具备唯一性，识别用不到，故剔除） inletter = False # 重置inletter为False # 最后一个字符贴边 if start != letters[-1][0]: # 如果当前的start和letters中最后一个start不等，后面还有字符，即字符贴边 letters.append((start, image.size[0])) # 最后一个字符的结束位置，即图片的宽度 return letters 2、横向切片12345678910111213141516def deal_row(self): ''' 单个字符横向处理 :return: ''' for captcha in self.captcha_firstsplit_paths: img = Image.open(captcha) # 横向切 top, botton = self.split_row(img, 0, img.size[1]-1) # 切割，并保存文件 try: im_spilt = img.crop((0, top, img.size[0], botton)) new_path = '&#123;0&#125;split__&#123;1&#125;'.format(self.img_dir, captcha.split('/')[-1]) im_spilt.save(new_path) except: pass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263def split_row(self, image, start, end): ''' 寻找验证码横向的切割边界 :param image: :return: ''' inletter = False # 表示当前在字符内部 if start &gt;= end: # 递归出口 return None, None mid = int((end - start) / 2) # 图片中间行 inletter = self.is_row_have_black(image, mid) # 中间一行出现黑像素表示进入字符中 if inletter == True: # 在字符中间 outletter_up = False # 是否出字符（上半部分），False表示没出字符，True表示已经出字符 outletter_down = False # 是否出字符（下半部分），False表示没出字符，True表示已经出字符 for i in range(1, int(mid) + 2): # 向两边发散，考虑到图片高度为偶数，从中间移动mid的距离不足以到达图片边界， # 特此将移动距离mid+2 # 向上 if outletter_up == False: row_have_black = self.is_row_have_black(image, mid - i) # 上i行是否有黑像素 if row_have_black is False: # 向上第一次全白的行 top = mid - i + 1 outletter_up = True # 已经出字符 if mid - i == 0: # 贴顶 top = 0 outletter_up = True # 向下 if outletter_down == False: row_have_black = self.is_row_have_black(image, mid + i) # 下i行是否有黑像素 if row_have_black is False: # 向下的第一行全白，下到底 botton = mid + i outletter_down = True if mid + i + 1 == image.size[1]: # 贴底 botton = mid + i + 1 outletter_down = True if outletter_up == True and outletter_down == True: if botton - top &gt;= 4: # 如果宽度大于等于4像素，返回top,botton return top, botton return None, None # 如果宽度小于4像素，返回None，None（即i、j的首部的点） # 不在字符中间，即字符位于上半部分或下半部分，或是i、j首位分离 else: top_up, botton_up = self.split_row(image, start, mid - 1) top_down, botton_down = self.split_row(image, mid + 1, end) if top_up != None and botton_up != None: # 字符在上半部分或i、j尾部在上半部分 return top_up, botton_up else: # 字符在上半部分或i、j头部在上半部分，尾部在下半部分 return top_down, botton_down pass 123456789101112def is_row_have_black(self, image, row): ''' 判断该行是否有黑像素 :param image: 图片对象 :param column: 图片的行 :return: ''' for i in range(image.size[0]): pix = image.getpixel((i, row)) # 获取图片某点的像素值 if pix != 1: # 不为白 return True return False","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://mrleecn.cn/tags/验证码识别/"}]},{"title":"位运算技巧总结（python版）","date":"2019-05-19T01:44:54.000Z","path":"2019/05/19/位运算/","text":"1. 不用临时变量交换两个数异或运算 两个相同的数异或为0 即n ^ n = 0； 任何数与0异或为它本身，即n ^ 0 = n。 支持交换律、结合律 123a = a ^ b # （1）b = a ^ b # （2）a = a ^ b # （3） 解释如下： 把（1）中的 a 带入（2）中，则有 b = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a 同理将（1）、（2）的结果带入（3）中，则有 a = a ^ b = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b 2. 判断一个数的奇偶性与运算 相同为0，不同为1 判断一个数n是偶数还是奇数，只需要判断n的二进制最后一位是1还是0。是0表示是偶数，是1表示是奇数。 1if n &amp; 1 == 1: # n为奇数 3. 乘2/除212n &lt;&lt; 1 # 左移一位，表示乘2n &gt;&gt; 1 # 右移一位，表示除2 4. 取两个数中的最大值12def max(a, b): return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31) 解释如下： b &amp; ((a-b) &gt;&gt; 31)其中(a-b) &gt;&gt; 31 表示取(a-b)的符号位。 当b &lt;= a时，符号位为0，b &amp; 0 = 0 当b &gt; a时，符号位为-1。b &amp; -1 = b 即当b &gt; a时结果为b，否则结果为0。 a &amp; (~(a-b) &gt;&gt; 31)其中(~(a-b) &gt;&gt; 31) 表示对(a-b)的符号位取反。 当a &gt;= b时，取反结果为-1，a &amp; -1 = a 当a &lt; b时，取反结果为0，a &amp; 0 = 0 即当a &gt;= b时结果为a，否则结果为0。 最后对前两步结果进行或运算，因为前两步的结果中一定有一个为0，另一个非0（即最大值）。所以经过或运算后结果非0（即为最大值）。 5. 取两个数中的最小值12def max(a, b): return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31) 6. 取绝对值12def abs(n): return (n ^ (n &gt;&gt; 31) - (n &gt;&gt; 31)) 7. 找出只出现一次的数字 在一组整型数据中，只有一个数字出现了一次，其余数字都出现了两次。找出那个只出现一次的数字。 由异或运算的特性可知：两个相同数字进行异或结果为0；一个数和0异或结果为它本身；且异或支持交换律和结合律。所以只需要对全部的数字进行异或运算，结果就是只出现一次的数字。如l = [1,2,1,0,0] 1 ^ 2 ^ 1 ^ 0 ^ 0 = (1 ^ 1) ^ (0 ^ 0) ^ 2 = 0 ^ 0 ^ 2 = 2 1234567def find_only(l): tmp = l[0] for i in range(1, len(l)-1): tmp ^= l[i] return tmpl = [1,2,3,4,4,3,1,0,0]","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"编程技巧","slug":"编程技巧","permalink":"https://mrleecn.cn/tags/编程技巧/"}]},{"title":"Git使用（二）","date":"2019-05-17T01:10:50.000Z","path":"2019/05/17/git使用二/","text":"本笔记摘抄自Git教程，仅记录自己学习过程，侵删。 工作区与暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 git-repo 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 继续修改，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： git-stage 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 现在版本库变成了这样，暂存区就没有任何内容了： git-stage-after-commit 修改readme.txt。你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。有两种方法： 你可以手动删去最后一行 你可以使用git命令进行删除 撤销修改用git status查看一下： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 你可以发现，Git会告诉你 git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 如果你还没使用git add把readme.txt文件添加到暂存区，那么可以使用git checkout -- file将工作区的修改全部撤销。 git reset HEAD &lt;file&gt;可以丢弃暂存区的修改 1234$ git reset HEAD readme.txtUnstaged changes after reset:M LICENSE.txtM readme.txt 如果你已经使用git add把readme.txt文件添加到暂存区，那么可以使用git reset HEAD &lt;file&gt;将暂存区的修改全部撤销。然后再使用git checkout -- file撤销工作区的修改。 删除文件添加一个新文件test.txt到Git并且提交： 123456$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 然后，手动删除工作区的test.txt文件。 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 这时候，出现两种情况： 情况1：文件删错了，要恢复文件1$ git checkout -- test.txt 现在，文件又在工作区出现了。 情况2：删的没错，清除版本库刚提交的test.txt方法一：使用git rm命令 1234567$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 方法二：使用git reset HEAD &lt;file&gt; 1$ git reset HEAD test.txt","tags":[{"name":"Git","slug":"Git","permalink":"https://mrleecn.cn/tags/Git/"}]},{"title":"time模块和datetime模块常见用法总结","date":"2019-05-16T07:41:50.000Z","path":"2019/05/16/time模块和datetime模块常见用法总结/","text":"time模块1import time 1. 获取当前时间123456&gt;&gt;&gt; localtime = time.localtime()&gt;&gt;&gt; localtime time.struct_time(tm_year=2019, tm_mon=4, tm_mday=25, tm_hour=16, tm_min=28, tm_sec=27, tm_wday=3, tm_yday=115, tm_isdst=0)# 2019年4月25日 16时28分27秒，本周的第3天（0是周一），本年的第115天，不是夏令时。&gt;&gt;&gt; type(localtime) # 时间元组类型&lt;class 'time.struct_time'&gt; 时间元组格式 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 一年中的第几天，1 到 366 8 tm_isdst 是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1 2. 分别获取当前年、月、日、今年第几天 等信息123456789&gt;&gt;&gt; year = localtime[0]&gt;&gt;&gt; month = localtime[1]&gt;&gt;&gt; day = localtime[2]&gt;&gt;&gt; year,month,day(2019, 4, 25)&gt;&gt;&gt; wday = localtime[6] # 本周第几天3&gt;&gt;&gt; yday = localtime[7] # 今年第几天115 3.获取当前时间戳123# 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数&gt;&gt;&gt; time.time() 1556182332.531831 4. 格式化时间（带时间戳）12&gt;&gt;&gt; localtime.strftime('%Y-%m-%d %H:%M:%S',x)'2019-04-25 16:28:27' python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 5. 推迟调用线程的运行1time.sleep(30) # 推迟30秒 datetime模块1. 获取当前时间123import datetime&gt;&gt;&gt; print(datetime.datetime.now())2019-04-25 17:11:02.275448 2.将时间戳转换成日期12&gt;&gt;&gt; print(datetime.date.fromtimestamp(1556182332.531831))2019-04-25 3.时间运算123456789101112# 当前时间+3天&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(+3)datetime.datetime(2019, 4, 28, 17, 14, 13, 969413)# 当前时间-3天&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(-3)datetime.datetime(2019, 4, 22, 17, 15, 11, 753718)# 当前时间+3小时&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(hours=3)datetime.datetime(2019, 4, 25, 20, 15, 42, 442473)# 当前时间+30分钟&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(minutes=30)datetime.datetime(2019, 4, 25, 17, 47, 2, 610058)","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"Git使用（一）","date":"2019-05-15T13:06:50.000Z","path":"2019/05/15/git使用一/","text":"本笔记摘抄自Git教程，仅记录自己学习过程，侵删。 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 创建一个版本库创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit pwd命令用于显示当前目录。 初始化第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 现在我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步： 用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步：用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 修改readme.txt文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 查看仓库当前状态运行git status命令看看结果： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 查看某个文件修改情况虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 1$ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： 123$ git commit -m &quot;add distributed&quot;[master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： 123$ git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 查看历史修改在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线 版本回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 123456789┌────┐│HEAD│└────┘ │ └──&gt; ○ append GPL │ ○ add distributed │ ○ wrote a readme file 改为指向add distributed： 123456789┌────┐│HEAD│└────┘ │ │ ○ append GPL │ │ └──&gt; ○ add distributed │ ○ wrote a readme file 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 查看历史命令现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。","tags":[{"name":"Git","slug":"Git","permalink":"https://mrleecn.cn/tags/Git/"}]},{"title":"【转载】写给年轻程序员的10点启示","date":"2019-05-14T12:24:47.000Z","path":"2019/05/14/写给年轻程序员的10点启示/","text":"1转载自：https://segmentfault.com/a/1190000013972995， 侵删 写给年轻程序员的10点启示1. 正确认识自己相比码农、程序猿、软件工程师、张江男、屌丝程序员等等这些网络词汇，当你把自己看作是一个屌丝程序员的话，那你也可能就是那个衣食不愁，但整天浑浑噩噩、无所追求的屌丝。我更愿意用技匠这个词来形容程序员，就像我给自己起的花名一样。程序员应该是那些不断追求更高技术，并有着自己产品梦的工匠。当你通过对自己技术不断打磨，一次又一次做出那些优秀产品的时候，你会发现自己不再是他人口中的码农或是屌丝，而更多被称为了大师、大神，而受到大家的尊重。 2. 比一般人更加努力优秀的程序员往往会被同天才或高智商的人联系在一起，但我想告诉你，你周围所看到的那些天才（身边的优秀程序员）只是在你没看到的时候花了更多时间工作或者学习而已，当你也坚持这么做时，你也会变得和他们一样优秀。 3. 适时建立个人权威建立个人权威，这能让其他人看到你的不同之处，并为你在公司或团队内部构建起良好的影响力。当然，这一切的前提是你通过不断努力积累了自己的实力，并在恰当的时候去展现它。 4. 遵循最佳实践技术更新太快，作为程序员，如何才能适应这种变化呢？其实，就像每年都会有新的流行设计趋势，然而设计的本质和原则却始终不变一样。这些最佳实践或由此衍生出来的框架、工具都是那些富有经验的程序员通过大量实践，总结出来的最优秀的软件开发思想。通过理解和对它们的有效实践，能够让你站到前人的肩膀之上，对软件开发本身获得更深入的理解和认识。 5. 保持好奇心并乐于探索新的事物优秀的程序员们也往往非常乐于探索那些看似与工作无关的技术。比如，做后端的程序员去学习前端的技能，前端工程师则去学习UI设计，等等，这些虽不会让他们成为那一个领域的专家，但技术往往是相通的，当你在探索这些新鲜事物的同时，你会发现你原有的技能也得到了提升。 6. 抛开代码与人沟通“紧盯着电脑屏幕，不断敲击键盘，目光有些呆滞。”这可能是程序员给人的印象。而我所看到的那些优秀的程序员却都不是这样的，他们往往兴趣广泛，并且都乐于与人沟通交流。程序员们很容易会忽视与人的沟通，这其实对他们的职业生涯发展是不利的。我很支持那些年轻的程序员们坚持去走技术路线，但这不应该成为你排斥与人沟通的理由。你需要与人沟通来获得他人的帮助；你需要与人沟通来建立良好的工作关系；当你的能力不断提升，被赋予更多职责时，你更需要与人沟通来管理好自己的团队，以及与老板或客户进行有效的沟通等。 7. 要为优秀的人工作环境对一个人的影响是巨大的，而最可怕的是当你身处其中时，很难意识到你正在变得越来越糟。我之前带过一些不错的程序员，他们中的一些人去了一些整体氛围或环境不是太好的公司。过了一段时间后，再次与他们碰面聊天时，我发现他们的思维、观点相较之前并没有提升，有些甚至反而退步了。 8. 生活、睡眠、旅行我希望每个程序员都能明白工作、技术、写代码这些并不是你存在的意义，而生活才是，你需要懂得生活，并且学会生活。 生活：尝试有节制和有规律的生活，程序员生涯绝不是一次冲刺，而更像一场马拉松。 睡眠：很多人觉得睡眠是弱者的表现，他们往往会长时间熬夜，其实我觉得这是这一种恶性循环，反而会使你的工作效率变的更低。 旅行：去任何一个新的地方都可以称之为旅行，让你发现和感受新的东西，而这些是从电脑屏幕上无法获得的。 9. 相信自己的天赋和创造力每个人的身上都有属于他自己的天赋和创造力，但它们也绝不是与生俱来的，你需要在生活中不断地培养和发掘它们。下面是我觉得一些行之有效的方法。 阅读优秀的书籍：好的想法绝不是凭空产生的，尝试从书中寻找那些能激发你创意和灵感的优秀内容。 记录和收集：尝试用一个小本子，将你转瞬即逝的好想法记录下来，它们可能并不直接有效，但下一个更好的想法可能就是从这些你记录下来的想法中产生的。 尝试动手：光有好的想法是不够的，你需要成为一个有工匠精神的人，通过亲自动手去尝试和实践，你会不断从中得到新的创造力。 10. 如果上面提到的其他建议都对你无效，那么就请坚持第2点吧，因为它将成为你最大的竞争优势。那些程序员们后知后觉的职涯经验1. 你的薪酬与工作量无关换句话说你是否容易被取代。公司很容易找到一个和你差不多的应届毕业生，而那些对公司产品非常熟悉，并且起到关键作用的老员工，要想替代他们，公司所需要付出的代价及需要承担的风险就会高得多。所以，不妨摆正心态，正确认识到自己在公司中的位置，努力修炼内功，让自己变得越来越重要，相信你的薪资也会随之提升的。 2. 尽可能持续做一件事既然你对于公司的价值来自于你的不可替代性，那又该如何有效提升它呢？我的建议是尽可能持续做一件事。这既是指技术上的积累，也是指你能完整或较长时间参与同一个项目或开发一个产品。 技术深度及完整项目经验的重要性，如果你总是在跟随那些新出现的技术和框架，那你很难在某一项技术上达到理想的深度；同样，在一个公司里，如果你总是在更换项目，那你也很难提升自己的价值。参与10个项目，不如完整参与一个项目。持续做一件事是要你把每一件事做透、做好，而不是蜻蜓点水，浅尝辄止。 3. 唯一不变的就是变化本身作为程序员，我们又应该如何应对这些变化呢？我想说，你很难去改变所处的环境，或是阻挡那些变化的大趋势。你所能做的恰恰是培养自己持续学习的能力。 4. 你的声誉非常重要除了那些经常挂在嘴边的诚实守信、踏实肯干等之外，有一点特别重要，那便是严谨。因为它往往是判断一名程序员是否具备优秀潜质的重要因素。严谨的程序员对于分配给自己的任务会认真理解，对于自己的产出会仔细检查，这些都能大大减少工作中的出错概率，给团队或公司中的其他人留下良好的印象。 5. 理解沟通的意义当我们没有对问题有深入理解的时候，我们很难写出正确的程序来，因此我们需要向用户虚心求教，去真正理解他们所希望解决的问题。 6. 你的右脑将是你成功的关键谈到那些我们眼中非常成功的技术大牛、IT高管，都会出人意料地将一些非技术能力作为自己获得成功的关键。比如，编写文档或做PPT的能力、演讲的能力、说服他人的能力，等等。我虽然并不完全赞同最优秀的程序员不写代码这种观点，但我确信你的右脑将会是决定你能否成功的关键。 7. 不要轻易说简单和不可能年轻程序员们不应该轻易做出那些过于绝对的判断，应尽可能去使用科学的方法进行分析和论证，然后用不易被人误解的方式进行有效的表达，这样你提出的观点才能让大家感到信服。 8. 你不应该总是单打独斗如果你真的希望做出一些具有影响力的东西，那么光靠个人是很难实现的。你需要和团队中不同角色的人进行合作，有时候你需要说服别人，有时候你则会被别人说服。 9. 让你的能力显而易见那些优秀的程序员无时无刻不在体现他们的能力，从轻松地解决技术难题，到会议上提出被一致认可的解决方案，以及他们写出的那些优雅且完善的代码，这些都让他们显得与众不同，仿佛是天生的优秀程序员。但我想说，他们其实都是那些努力并使用了正确方法的人。程序员的能力来自于大量的编码实践，以及持续学习的能力和勤于思考的习惯。任何自作聪明，不懂装懂，以及投机取巧在明眼人看来都只会是东施效颦，显得如此微不足道。 每个程序员都应该了解的一件事我曾经接触过一些IT高管及行业的技术大牛，当私下聊起他们是如何变得如此出类拔萃时，他们大多会以自嘲但又略带得意的语气来讲述他们的那些独门秘籍。 我的文档写得特别好。 我的口才很好，总是能成功说服别人。 我的PPT做得非常棒，是公司里数一数二的。 我写过几篇很受欢迎的技术文章。 我热爱开源文化，并在社区里很有名气。 …… 我发现，这些普通人眼中的大神们很少会提及自己的技术有多牛，反而更多地把功劳归于那些看似与技术毫无关系的能力。大家千万别误以为他们只是一群华而不实，靠着一些小伎俩往上爬的小人。完全不是，而且我敢向你保证，他们中的每一个人在担任程序员或负责其他技术工作时，同样都有着非常出色的技术能力和优秀的工作表现。但为什么在他们眼中这些还不足以使他们达到现在的高度，反而是那些不起眼的写文档、做PPT、演讲等这些技能使他们能够在一次次竞争中胜出，并成为了我们中的佼佼者呢？ 其实在我看来，他们所谓的这些秘籍，都可以归纳为一种能力，那就是自我营销。 一名程序员如果能够尽早意识到自我营销的重要性，并有意识地锻炼和运用这种能力，那将对你的事业产生有益的帮助。 那么对于程序员们来说，又有哪些能够提升自我营销能力的方法呢？下面便是我的一些建议。 1. 读与技术无关的书我建议只买一些经典的技术书籍来帮你打基础，然后从网上去学习一切新的东西。我尤其鼓励大家去读那些与技术无关的书籍。程序员不善于自我营销，其中一个重要原因是他们自身所掌握的知识体系太过于单一，很难跳出技术范畴与人交流，并引起别人的兴趣和认同。你可以读任何历史、经济、人文、艺术类的书籍，它们都能够帮助你丰富自己的知识和思想，使你变得更加全面和完善，而这反过来，又能帮助你建立信心。 2. 会写文档文档可能是你完成代码编写后一个最佳的展示机会。当代码实现了它的功能之后，就很少有人会再去看它，除非它出错了。但文档被阅读的概率却大得多。从一个文档中，我们可以看到关于作者的很多东西，思路是否缜密，逻辑性是否强，设计方案是否优秀，等等。可以说，文档质量的高低是衡量一名程序员是否优秀的重要标准之一。 3. 学会包装说到包装，人们往往会产生一种不好的感觉，把它与虚伪、假的东西联系在一起。其实，我所说的包装应该包含两层意思： 知道什么是美的（优秀的）。 精心制作。 作者举例一个普华永道的高级经理通过一个长达114页的非常精美的PPT而赢得了保监会关于偿付能力改革的会议。 在日常工作中，我经常发现身边的程序员很难写出美观整洁的文档或PPT来。这一方面与我们从小缺乏美学教育有关，而更重要的往往是他们并没有真正用心去制作它。其实，我们可以通过寻找一些优秀的文档示例来学习如何制作优秀的文档，这其实并不困难。知道什么是优秀的，然后像写你的代码一样用心去制作就行了。 4. 尝试多讲讲话一直是很多程序员的硬伤，当然这也曾是我的硬伤。根据我的经验，你需要跨过以下两个障碍： 敢说。 让说的和你想的一致。 5.建立社会化联系一个完全封闭的程序员一定不是一个优秀的程序员。优秀的程序员往往愿意并善于与他人交流，分享自己的经验和想法，并在交流中获得有益的东西。这样做有很多好处： 通过这些社会化的活动能够使你的想法和技能更加完善。 能够使你建立权威，你的技术博客，在一些社区上的技术问题解答，以及你的开源项目等都会使人认为你是这方面的专家。 同样，你也可以获得他人的帮助，来解决棘手的难题。 你可以找到与你有相同兴趣的人，一起做有趣的事情。 你的社交网络将因此扩大，这意味着你所获得的机会将会更多。 程序员的烦恼1. 是否还应该留在一线城市一切都能为你的生活赋予意义，并让你感到更加快乐的话，那你还是应该更坚定地留下，而非选择离开。 2. 小公司做的事情太繁杂了时常会说“杂事不杂”，虽然看着被很多与技术无关的事务缠身，但它们对你来说同样具有意义。你从中可能获得沟通能力、管理能力、建立更广的人脉，在企业内部建立影响力，等等 3. 创业公司中的危机感无论成功与否，经历一次完整的创业都将让你受益匪浅。你将学到很多在大公司仅仅做一颗螺丝钉所学不到的东西。虽然在此过程中，你一定会有挫败感、焦虑，但或许坚持一下就会看到曙光。 另外一点我想说的是，创业的过程将让你获得不同的眼光。创业大多是在一个新的领域中进行的，你不应仅仅专注于公司所使用的那些技术，而更需要通过深入理解这个新的领域，去获得不同的视角和眼光，因为它们也会在未来成为你的核心竞争力。 4. 技术单一，想学习更多我总是很鼓励身边的程序员们去涉猎不同的技术甚至领域，但前提是你必须首先对某一门技术做到精通。技术是需要深耕的，深入学习一门主流的开发技术，并不断提升编程思维，比对很多技术栈都浅尝辄止要好很多。因此，如果精力有限不妨先学好一门技术，你会发现之后再去学习其他技术会变得容易许多，因为它们之间往往都是相通的。 5. 我想自学编程，应该学哪一门语言？如果你真的没有任何思路，只是希望你学的这门编程语言能够有用，我的建议是JavaScript，因为它看起来是唯一可能在未来所有领域内得到应用的编程语言，从我们的移动设备，到传统的Web应用，再到服务器端开发甚至是硬件编程，它几乎无处不在。 6. 大专学历，能进大公司吗？全日制本科几乎成了所有内部职位的最低要求，所以学历上的缺失确实会成为你进入大公司的障碍。当然还是有例外的情况： 通过内部员工的推荐。 通过外包公司进入后，再转为内部员工。 努力成为某一领域的专家，或者建立个人影响力。 如果你还是一名大专在读学生，那么我希望你不要过早焦虑，尝试问问自己除了学历之外还有什么让你能够脱颖而出的东西？是否有自己的个人项目？是否为知名的开源项目贡献过代码，甚至只是参与编写文档？是否通过写博客阐述过自己的独到观点，并得到大家的认可？在哪家公司实习过？这些都可能抓住雇主的眼球，从而弥补你在学历上的不足。 给年轻程序员的职涯建议1.尽早确定你想做的事情。尽早确定自己想做的事情——你的职业目标，意味着你可以获得比其他人更多的时间去努力。2.一万小时定律3.提高工作效率。有以下两点建议： 加快工作节奏 借助工具完成工作 4.简明的沟通方式5.持续学习6.学会控制情绪7.让最优秀的人围绕在你身边8.善于归纳与表达9.掌握英语10.睡眠是你更强大","tags":[{"name":"转载","slug":"转载","permalink":"https://mrleecn.cn/tags/转载/"},{"name":"职场","slug":"职场","permalink":"https://mrleecn.cn/tags/职场/"}]},{"title":"时间是怎么浪费掉的","date":"2019-05-13T14:06:50.000Z","path":"2019/05/13/时间是怎么浪费掉的/","text":"时间杀手最大的时间杀手–看电视危害2012年，尼尔森一份报告指出，两岁以上的美国人平均每周看电视直播的时间超过了34小时。这还不包括看录播节目。每周大概会花费40个小时看电视。 看电视不仅浪费时间，还会以你察觉不到的方式影响你的认知。电视节目把所有的问题都“短路”了， 让你不经过自己的大脑的任何思考就把一切都安排好。从消费习惯到世界观，均受电视直接影响。电视看的越多，你越会放弃对自己思想和行为的控制。 戒掉电视的方法一下戒掉看电视有些难，但我们可以通过一些方法一点一点逐步戒掉电视。 跟踪自己看电视的时长，想想自己都看那些节目，每周看多久。 不看直播。 合理规划自己看电视的时间，并严格控制自己不超时。长期坚持，慢慢减少看电视的时间。 寻求其他事情来占用自己看电视时间。 常见的时间杀手及解决办法 社交媒体和新闻网站 采用批处理的方式，你可以在一天内集中一两次进行社交媒体活动或查看新闻网站。即使这样也绝不会错过任何有用的东西。 不必要的会议 不必要的会议不要去。可以通过邮件处理的会议，用邮件处理。 玩电子游戏 强制自己不要玩。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]},{"title":"十步学习法","date":"2019-04-28T13:24:35.000Z","path":"2019/04/28/十步学习法/","text":"十步学习法为了能够掌握一门技术，需要了解以下三个要点： 如何开始 ：要想开始学习，现在需要掌握哪些基础知识。 学科范围 ：我现在学的东西有多宏大？我应该怎么怎样做？在开始阶段，不需要了解每个细节，但是需要对该学科的大概轮廓有所了解。 基础知识 ：不止在开始阶段，要想使用一项特定的技术，需要了解基本的用户案例和最常见的问题，也需要知道字节学的哪20%能满足80%的日常应用。 十步学习法体系基本思想 对自己要学的内容有个基本了解-了解自己不知道什么足矣。 利用这些信息勾勒出学习的范围，以及学成后又会获得什么。 利用上述知识，寻找各类资源，帮助自己学习。 制定自己学习计划，列出需要学习的课程，筛选学习材料，只保留能帮助自己达成目标的内容。 具体内容 第一步：了解全局 在深入研究某个主题之前至少要对其有所了解。这样才能弄清自己到底要学什么，才能找到最好的学习方法。 第二步：确定范围 明确自己的学习范围。运用上一步中获得的信息，让自己的关注点落脚到更小也更可控的范围。抵制该学习主题下的不同子主题的诱惑，尽可能专注于自己的学习范围。 第三步：定义目标 形成一份简明清晰的陈述，勾勒出你勤奋学习后的成功图景。确保其中包括具体的成功标准，从而能充分评估自己是否达到了学习目标。 第四步：寻找资源 通过多种途径，尽可能多的收集与自己所选主题相关的资源，此时无需考虑这些资源的质量。 第五步：创建学习计划 将自己的学习路径看作是自己写书时的大纲，结合第四步寻找到的图书目录，制定自己的学习计划。 第六步：筛选资源 把第四步中收集到的资源全部浏览一遍，找出那些内容能够覆盖到你的学习计划，结合评论，找出品质最高的资源。 第七步：开始学习，浅尝辄止 广度优先，获取足够多的与所学主题相关的信息。从而能让你开始学习，并在下一步计划中动手操作。 第八步：动手操作，边学边玩 无需提前了解全部内容，首先要做的就是亲自操作和亲身体验，在实践中学习。 第九步：全面掌握，学以致用 有效利用自己选择的资料，通过阅读文字、观看视频、与人交流等方式，沉浸在学习资料中，对知识深度挖掘。并试着把自己正在学习的内容和最终目标相关联。 第十步：乐为人师，融会贯通 走出自己的舒适区，将自己学到的知识交给别人。在这一过程中查缺补漏，切实剖析并理解自己所学知识，将其内化到自己思想。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"},{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"}]}]