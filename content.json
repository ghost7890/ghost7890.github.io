[{"title":"对Python中列表及元组运行机制的理解","date":"2019-05-30T13:03:17.000Z","path":"2019/05/30/listandtuple/","text":"本文为极客时间 Python核心技术与实战 专栏的学习笔记 相同点 Python 中的列表和元组都支持负数索引 列表和元组都支持切片操作 列表和元组都可以随意嵌套 两者也可以通过 list() 和 tuple() 函数相互转换： 12345list((1, 2, 3))[1, 2, 3]tuple([1, 2, 3])(1, 2, 3) 列表和元组常用的内置函数：123456789101112131415161718192021l = [3, 2, 3, 7, 8, 1]l.count(3) 2l.index(7)3l.reverse()l[1, 8, 7, 3, 2, 3]l.sort()l[1, 2, 3, 3, 7, 8]tup = (3, 2, 3, 7, 8, 1)tup.count(3)2tup.index(7)3list(reversed(tup))[1, 8, 7, 3, 2, 3]sorted(tup)[1, 2, 3, 3, 7, 8] 解释如下： count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。 不同点 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 不能给元组增删元素 12345tup = (1, 2, 3, 4)tup[3] = 40Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment 如果需要对已有元组进行“改变”，就必须开辟新的内存空间，创建新元组。 代码示例如下： 123456789tup = (1, 2, 3, 4)new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值new _tup(1, 2, 3, 4, 5)l = [1, 2, 3, 4]l.append(5) # 添加元素 5 到原列表的末尾l[1, 2, 3, 4, 5] 列表和元组存储方式的差异1. 存储差异1234567&gt;&gt;&gt; l = [1, 2, 3]&gt;&gt;&gt; l.__sizeof__()64&gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; tup.__sizeof__()48 可以看到，对列表和元组，我们放置了相同的元素，但是元组的存储空间，却比列表要少 16 字节。这是为什么呢？ 事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。 1234567&gt;&gt;&gt; l = []&gt;&gt;&gt; l.__sizeof__() // 空列表的存储空间为 40 字节40&gt;&gt;&gt; t = () // 空元组的存储空间为 24 字节&gt;&gt;&gt; t.__sizeof__()24 继续在列表中添加元素，观察列表内存空间的变化： 123456789101112131415l.append(1)l.__sizeof__() 72 // 加入了元素 1 之后，列表为其分配了可以存储 4 个元素的空间 (72 - 40)/8 = 4l.append(2) l.__sizeof__()72 // 由于之前分配了空间，所以加入元素 2，列表空间不变l.append(3)l.__sizeof__() 72 // 同上l.append(4)l.__sizeof__() 72 // 同上l.append(5)l.__sizeof__() 104 // 加入元素 5 之后，列表的空间不足，所以又额外分配了可以存储 4 个元素的空间 上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。 但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。 在数据量非常庞大时，列表和元组之间存储空间上的差距差别会非常明显，所以选择合适的数据结构很关键。 2. 性能差异通过上面的例子，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。 另外，Python在后台会对静态数据做一些资源缓存，由于垃圾回收机制的存在，一些变量不被使用就会被Python收回它们所占的内存。 对于元组来说，如果占用空间并不大，Python会暂时缓存这部分，下次创建同等大小的内存就不必再去向操作系统申请，大大加快了程序运行速度。 总结存储数据和数量不变时，用元祖。数据和数量可变时，用列表。 初始化，元组快 索引操作，二者速度差不多 增加、删除，列表更优","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"【软技能】攀登晋升阶梯（二）","date":"2019-05-27T14:10:10.000Z","path":"2019/05/27/softskills2/","text":"本文笔记范围为书中的第9章。 攀登晋升阶梯关于晋升，书中提到的几条建议： 承担责任 引人注目 自学 成为问题的解决者 下面分别对这几条建议进行阐述。 承担责任在任何公司能让你脱颖而出的最重要的法宝就是承担更多的责任。金钱总是追随着责任。有任何机会去承担更多责任时，请承担起来！ 没有人愿意涉足的领域是搜寻机会最好的地方。因为没有人愿意涉足，所以无需去抢，这些就成为你日益强大的帝国的领地。如果你能把沼泽变为良田，你也就展现了自己的价值。 另一种承担责任的方式是成为团队中其他人的导师。自愿帮助新人加速成长。通过介入和解决别人的问题，不仅可以学到更多自己专业以外的知识，而且随着时间推移，你在团队中逐步树立“及时雨”的名声。这样的声誉可能会让你成为团队领导或其他管理职位。 引人注目如果找不到方法让你的老板和高层管理员知道你在做什么，那你的努力都是徒劳。 文中作者引起老板注意的方法： 每当开始新工作时，我（该书作者）所做的第一件事就是记日志，记录每天的时间都花在什么地方，完成了哪些工作。将这些信息汇总成周总结，每个周五发给上级领导。这份周报确保我每周都会被上级领导注意到。 其他方式： 提供演讲或培训——选择一个对你团队有用的话题。 发表意见——只哟啊在会议上就这么做，或者只要你能得到机会就这么做。 保证”曝光度“——定期与老板会面，确保你经常被注意到 自学自学能让升职加薪变得容易，因为你可以很清楚地表明：现在的自己比之前更有价值。 你应该不断学习新东西，提升自己的技能。报名参加培训课程，或者考相应的资质证书，都能表明你致力于不断提升自己。你掌握的东西越多，随之而来的机会就越多。 分享自己学到的东西。你可以通过演讲的方式，分享自己的知识，也可以创建自己的博客、为杂志写文章或写书。外部曝光有助于你建立自己在该领域的权威地位，也让你看起来对公司更有价值。 成为问题的解决者如果你能解决别人无法解决或不愿解决的问题，无论在哪家公司，你都能轻而易举地成为最有价值的人。 有时候只要意识到自己的工作毫无前途，就需要寻找更好的机会。无论什么原因，你可能都需要换工作。","tags":[{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"}]},{"title":"【软技能】从非同凡响开始（一）","date":"2019-05-25T16:18:10.000Z","path":"2019/05/26/softskills1/","text":"《软技能 代码之外的生存指南》读书笔记——职业篇（一） 说明本文是《软技能 代码之外的生存指南》读书笔记的第一篇，通过记录读书笔记的方式，来复盘书中的一些自己有所感悟的内容。 本文笔记范围为书中的第2、3、4章。 一、从非同凡响开始：绝不要做他人都在做的事转变思维时代已经变了，尽管在你的职业生涯的某个特定时间段里，可能在为某个公司打工，但不要让那个特定的角色固化你和你的职业生涯。尝试转变心态，把自己当作一个企业去思考，从被一纸“卖身契”束缚住的仆人转变为一名拥有自己生意的商人，积极主动地管理自己的职业生涯。 如何像企业一样思考从思考企业的构成开始，大多数成功企业都需要以下几样东西： 一个产品或服务 不提供商品的企业是无法赚钱的，你有什么可卖？你的产品或服务是什么？ 关注市场营销 想要赚钱，就必须能让潜在客户了解该产品或服务。产品营销做得越好，服务定价就越高，也越有机会吸引更多的潜在客户。 想方设法提升你的服务 服务质量与企业的发展成正相关。 思考产品或服务的具体方向 你可以专注为那一特定类型的客户或行业提供特定的服务。 成为行业专家 集中精力成为一名专家，专门为某一特定类型的客户提供专业的整体服务（只有你真正专注于一类客户，才能找到非常好的工作）。 采取行动 想象一下：有一家企业，拥有某个 产品或服务。他们将如何推广这一产品或服务从而做到卓尔不凡？ 如果只用一句话来描述你的能为潜在雇主或客户提供怎样的特定服务，这句话是什么？ 二、思考未来：你的目标是什么如何设定目标树立一个大目标起初阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。 因为很难清晰地界定远期可能发生的事情，所以大目标： 不够具体，只需要具体到能给你提供清晰的方向 如同航海一般，刚开始，我们没必要立刻知道要驶向的港口的精确经纬度，只需要朝着目标港口航向前进。随着离目标越来越近，就能获得更多数据，不断修正航线，最终到达目标港口。 不需要那么具体，但必须足够清晰，能够让你知道自己是在向它靠近还是远离 建立小目标如果你可以驱动小目标逐渐靠近你的大目标，那么最终你一定功能到达目的地。 设定大小不同的目标，确保你向着自己的大目标前进，这一点非常重要。 合理小目标的好处： 较小的目标可以保证自己航行在正确的轨道上，不会偏离最终大目标。 达成小目标，让我们感觉良好，帮助我们继续前进。 较小的目标不像大目标那样令人望而生畏。 追踪你的目标定期核对自己目标，反思自己在短期和长期取得的成果是大有裨益的，你能够弄清楚自己是否取得了合理的进展，或是是否要进行某些调整。 采取行动 为你的职业生涯设置至少一个大目标。 将大目标分解成相应的若干小目标，例如： 月目标 周目标 每日目标 把你的大目标卸载自己每天必经之地，每日三省吾身——我在追求什么。 三、人际交往能力：远比你想象的重要人际交往的你需要知道的重要原则1. 每个人都希望感到自己很重要以自己为核心，每个人都希望自己很重要。这是人类最深邃、最致命的欲望之一。也是社会和生活中取得伟大成就的主要动机。 如果你希望人们接受你的想法，并认可其中价值，首先你最好主动给他人同样的礼遇。如果你不能保全他人的自醉，那你永远也不可能赢得他的心。 2. 永远不要批评“批评”是一项很少能够达成你期望结果的工具。 奖励积极行为要比惩罚消极行为有效得多。如果你想激励团队鼓舞士气，那就用表扬替代批评吧。 3. 换位思考停用”我”和“我想要什么”来思考，开始思考对他人而言什么才最重要，什么才是他们需要的。 从对方的心态出发提建议。 4. 避免争吵如果你认为“该怎么做某事”与他人产生分歧，那么在多数情况下，你最好能确定分歧点是否值得你拼命维护。小事情上，任何放弃立场或承认错误的机会对你而言可能没什么大不了的，但对他人却可能是举足轻重的，这么做不仅能为你赢得不可估量的尊重。也能为你的未来积蓄财富，形势逆转时即可兑换使用。","tags":[{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"}]},{"title":"字符带旋转的验证码识别思路（Python）","date":"2019-05-22T08:26:14.000Z","path":"2019/05/22/yzm-thinking/","text":"背景介绍为了实现某网站的模拟登录，需要对验证码进行识别，该验证码除了有背景的干扰图案之外，字符也有不同角度的倾斜，高度也不统一，如下图所示： mark mark 面临的问题经过各方查找，网上大多数验证码识别教程都是字符规整且直立的验证码，方法也都大同小异。 字符粘连在一起就切片，自己做验证码库进行识别； 没有粘连在一起，就通过机器学习、神经网络等方法进行识别。 对于没有学习过机器学习、神经网络的我，不能短时间上手。 解决思路于是，想到了采用切片做库的识别思路。 第一步：获取大量验证码图片下载大量的验证码（视情况而定，我选择了300张），为后面验证码切片做库做准备。图片最好保存为gif格式。 第二步：验证码图片预处理对第一步下载的全部验证码图片进行灰度化、二值化。 为保证经过预处理后的验证码图片效果，此处需要对二值化的阈值，进行仔细调整。 预处理代码如下： 1234567891011121314151617181920from PIL import Image def preprocessing(yzm_path='yzm.gif', new_yzm_path='yzm.gif'): ''' 验证码预处理，灰度化，二值化 :param captcha_path: 验证码图片路径 :param new_captcha_path: 经过预处理后验证码图片保存路径 ''' image = Image.open(yzm_path) # 灰度化 image = image.convert('L') # 二值化 table = [] for i in range(256): if i &lt; self.threshold: table.append(0) else: table.append(1) image = image.point(table, '1') image.save(new_yzm_path) 经过预处理后的图片如下图所示： mark 第三步： 验证码图片切片因为每个字符高度不统一，因此切片时除了要将每个字符单独切出来外，还要将字符四周多余空白行（列）也要去除。 这里将会出现一个问题，对于字符i、j在某些倾斜角度时，无法保证i、j切片的完整性。这里，我们选择性放弃i、j首部的点，而只留下尾部（因为首部的点相对于尾部，不具有辨识度）。 将全部经过预处理后的验证码图片进行切片操作。切片方法，请移步到我的另一篇博客验证码高效切片方法（Python）。 第四步：手动制作原始验证码库这一步最为繁琐。将第三步切片后的字符图片进行分类。可以借助打码平台帮你完成，也可通过自己手动对字符图片进行分类。制作原始的验证码库（我的分类方法：在一个空目录下建立以0-9、a-z命名的36个目录，将对应字符图片放到对应目录中）。 我的原始验证码库达到1500张字符图片。经测试识别率在70%。 第五步：验证码识别这一步可以参考Python计算图片之间的相似度 以下是我修改后的代码： 12345678910111213141516171819202122232425def get_similarity_degree(vector1, vector2): ''' 计算两图片的相似度 :param vector1: 图片1的向量 :param vector2: 图片2的向量 :return: 相似度 ''' # dot返回的是点积，对二维数组（矩阵）进行计算 res = dot(vector1, vector2) return resdef get_img_vectors(image): ''' 计算图片的余弦距离 :param image: Image图片对象 :return: 图片的向量 ''' image = image.resize(compare_img_size, Image.ANTIALIAS) # compare_img_size=(30, 30) vector = [] for pixel_tuple in image.getdata(): vector.append(average(pixel_tuple)) # linalg=linear（线性）+algebra（代数），norm则表示范数 # 求图片的范数 norm = linalg.norm(vector, 2) return vector / norm 第六步：实现验证码库自动更新进行大量的模拟登录（使用自己的验证码库做识别），当模拟登录成功且验证码字符与验证码库内字符切片相似度小于某个值（我选择的95%）时，将改验证码字符加入到验证码库中。 关键代码如下： 123456789101112131415 def yzmstore_update(self): ''' 将正确的验证码切片加入库中，以时间戳命名 :param result: 验证码字符串 :return: '''# self.yzmstore_waitupdate_img = ['./img_crop/z/split_0.gif', ....] letters_list = list(i[1].split('/')[-2] for i in self.yzmstore_waitupdate_img) # 获取验证码对应字符 ['z'] for i in range(len(letters_list)): new_yzm_dir = '&#123;0&#125;&#123;1&#125;/'.format(self.yzmstore_rootdir, letters_list[i]) time_stamp = time.time() # 当前时间戳 time.sleep(0.1) # 等待0.1s避免时间戳一致 new_yzm_name = '&#123;0&#125;split&#123;1&#125;.gif'.format(new_yzm_dir, str(time_stamp).replace('.', '')) # 去掉时间戳中的'.' old_yzm_name = self.yzmstore_waitupdate_img[i][0] shutil.move(old_yzm_name, new_yzm_name) # 将待添加的验证码图片移动到验证码库中 经测试，当验证码库达到5000张时，识别率达到94%。 细节部分由于计算图片向量值很耗时，所以可以提前将验证码库内字符图片的向量值提前计算好，进行模拟登录时，只需计算当前验证码的向量值，然后和已经计算好的验证码库的图片的向量进行相似度比较即可（比较速度非常快：不到0.5s）。从而减少整个模拟登录的时间。","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://mrleecn.cn/tags/验证码识别/"}]},{"title":"Numpy笔记","date":"2019-05-22T06:28:25.000Z","path":"2019/05/22/numpy/","text":"标准Python列表list的缺点标准的 Python 中，用列表 list 保存数组的数值。由于列表中的元素可以是任意的对象，所以列表中list保存的是对象的指针。虽然Python中隐区了指针的概念。但是数组有指针，Python的列表list其实就是数组。这样如果我要保存一个简单的数组[0, 1, 2]，就需要有3个指针和3个整数对象。这样对于Python来说是非常不经济的，浪费内存和计算时间。 为什么用Numpy为什么要用 NumPy 数组结构而不是 Python 本身的列表 list？这是因为列表 list 的元素在系统内存中是分散存储的，而 NumPy 数组存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表 list 还需要对内存地址进行查找，从而节省了计算资源。 另外在内存访问模式中，缓存会直接把字节块从 RAM 加载到 CPU 寄存器中。因为数据连续的存储在内存中，NumPy 直接利用现代 CPU 的矢量化指令计算，加载寄存器中的多个连续浮点数。另外 NumPy 中的矩阵计算可以采用多线程的方式，充分利用多核 CPU 计算资源，大大提升了计算效率。 当然除了使用 NumPy 外，你还需要一些技巧来提升内存和提高计算资源的利用率。一个重要的规则就是：避免采用隐式拷贝，而是采用就地操作的方式。举个例子，如果我想让一个数值 x 是原来的两倍，可以直接写成 x=2，而不要写成 y=x2。这样速度能快到 2 倍甚至更多。 Numpy基础NumPy 用字符编码来表示数据类型。如下表: 数据类型 字符编码 整数 i 无符号整数 u 单精度浮点数 f 双精度浮点数 d 布尔值 b 复数 D 字符串 S Unicode U Void V 创建数组12345678910111213141516import numpy as npa = np.array([1, 2, 3])b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])b[1,1]=10 # 直接修改数组元素print a.shape # 数组形状print b.shapeprint a.dtype # 数组类型print b结果：(3L,)(3L, 3L)int32[[ 1 2 3] [ 4 10 6] [ 7 8 9]] 结构数组12345678910111213141516171819202122# 自定义数组类型import numpy as nppersontype = np.dtype(&#123; &apos;names&apos;:[&apos;name&apos;, &apos;age&apos;, &apos;chinese&apos;, &apos;math&apos;, &apos;english&apos;], &apos;formats&apos;:[&apos;S32&apos;,&apos;i&apos;, &apos;i&apos;, &apos;i&apos;, &apos;f&apos;]&#125;)peoples = np.array([(&quot;ZhangFei&quot;,32,75,100, 90),(&quot;GuanYu&quot;,24,85,96,88.5), (&quot;ZhaoYun&quot;,28,85,92,96.5),(&quot;HuangZhong&quot;,29,65,85,100)], dtype=persontype)ages = peoples[:][&apos;age&apos;]chineses = peoples[:][&apos;chinese&apos;]maths = peoples[:][&apos;math&apos;]englishs = peoples[:][&apos;english&apos;]print np.mean(ages)print np.mean(chineses)print np.mean(maths)print np.mean(englishs)==================28.2577.593.2593.75 连续数组的创建np.arange 和 np.linspace 起到的作用是一样的，都是创建等差数组。这两个数组的结果 x1,x2 都是 [1 3 5 7 9]。结果相同，但是你能看出来创建的方式是不同的。12x1 = np.arange(1,11,2)x2 = np.linspace(1,9,5) 算数运算通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求n次方、取余的运算。1234567891011121314151617x1 = np.arange(1,11,2)x2 = np.linspace(1,9,5)print np.add(x1, x2) # 加print np.subtract(x1, x2) # 减print np.multiply(x1, x2) # 乘print np.divide(x1, x2) # 除print np.power(x1, x2) # n次方print np.remainder(x1, x2) # 取余==================[ 2. 6. 10. 14. 18.][0. 0. 0. 0. 0.][ 1. 9. 25. 49. 81.][1. 1. 1. 1. 1.][1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05 3.87420489e+08][0. 0. 0. 0. 0.] 统计函数 函数名 作用 注释 amax() 最大值函数 amin() 最小值函数 ptp() 最大值与最小值之差 percentile() 数组百分位数（） 百分位数的概念：第p个百分位数是这样一个值，它使得至少有p%的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值。 median() 中位数 mean() 平均数 average() 加权平均数 默认权值为1 std() 标准差 var() 方差 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import numpy as npa = np.array([[1,2,3], [4,5,6], [7,8,9]])# 最小值print np.amin(a) # 矩阵中最小元素print np.amin(a,0) # 按列计数的计数组中的最小元素print np.amin(a,1) # 按行计数的计数组中的最小元素1[1 2 3][1 4 7]===================# 最大值print np.amax(a) # 矩阵中最大元素print np.amax(a,0) # 按列计数的计数组中的最大元素print np.amax(a,1) # 按行计数的计数组中的最大元素9[7 8 9][3 6 9]===================# 最小值、最大值之差print np.ptp(a)print np.ptp(a,0)print np.ptp(a,1)8[6 6 6][2 2 2]===================# 百分位数（取值0-100）print np.percentile(a, 50) # 50表示取中位数print np.percentile(a, 50, axis=0)print np.percentile(a, 50, axis=1)5.0[4. 5. 6.][2. 5. 8.]==================# 中位数print np.median(a)print np.median(a, axis=0)print np.median(a, axis=1)5.0[4. 5. 6.][2. 5. 8.]==================# 求平均数print np.mean(a)print np.mean(a, axis=0)print np.mean(a, axis=1)5.0[4. 5. 6.][2. 5. 8.]===================# 加权平均值a = np.array([1,2,3,4])wts = np.array([1,2,3,4]) # 权重print np.average(a)print np.average(a,weights=wts)2.53.0===================# 标准差、方差a = np.array([1,2,3,4])print np.std(a)print np.var(a)1.1180339887498951.25=================== 排序1sort(a, axis=-1, kind=‘quicksort’, order=None) 默认情况下使用的是快速排序； kind 可以指定 quicksort 快速排序 mergesort 合并排序 heapsort 堆排序 axis 默认是-1，即沿着数组的最后一个轴进行排序也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。 order 字段，对于结构化的数组可以指定按照某个字段进行排序。1234567891011121314a = np.array([[4,3,2],[2,4,1]])print np.sort(a)print np.sort(a, axis=None) # 扁平化排序print np.sort(a, axis=0) print np.sort(a, axis=1) [[2 3 4] [1 2 4]][1 2 2 3 4 4][[2 3 1] [4 4 2]][[2 3 4] [1 2 4]]","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"数据处理","slug":"数据处理","permalink":"https://mrleecn.cn/tags/数据处理/"},{"name":"Numpy","slug":"Numpy","permalink":"https://mrleecn.cn/tags/Numpy/"}]},{"title":"Pandas中 Series、DataFrame","date":"2019-05-22T06:10:17.000Z","path":"2019/05/22/Pandas/","text":"Series是一个定长的字典序列。两个基本属性：index 和values 建立Series第一种方法12345678910111213141516from pandas import Series, DataFramex1 = Series([1, 2, 3, 4])x2 = Series(data=[1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])print(x1)print(x2)0 11 22 33 4dtype: int64a 1b 2c 3d 4dtype: int64 第二种方法123456789d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3, &apos;d&apos;:4&#125;x3 = Series(d)print(x3)a 1b 2c 3d 4dtype: int64 DataFrame类似于数据库表包括行索引和列索引 建立DataFrame1234567891011121314151617181920212223import pandas as pdfrom pandas import Series, DataFramedata = &#123;&apos;Chinese&apos;: [66, 95, 93, 90, 80], &apos;English&apos;: [65, 85, 92, 88, 90], &apos;Math&apos;: [30, 98, 96, 77, 90]&#125;df1 = DataFrame(data)df2 = DataFrame(data, index=[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;ZhaoYun&apos;, &apos;HuangZhong&apos;, &apos;DianWei&apos;], columns=[&apos;English&apos;, &apos;Math&apos;, &apos;Chinese&apos;])print(df1)print(df2) Chinese English Math0 66 65 301 95 85 982 93 92 963 90 88 774 80 90 90 English Math ChineseZhangFei 65 30 66GuanYu 85 98 95ZhaoYun 92 96 93HuangZhong 88 77 90DianWei 90 90 80 数据导入和导出Pandas支持直接从xlsx,csv等文件中导入数据，也可以导出到xlsx,csv等文件中。（可能少包，根据提示安装即可）12345import pandas as pdfrom pandas import Series, DataFramescore = DataFrame(pd.read_excel(&apos;data.xlsx&apos;)) # 导入score.to_excel(&apos;data1.xlsx&apos;) # 导出print score 数据清洗12data = &#123;&apos;Chinese&apos;: [66, 95, 93, 90,80],&apos;English&apos;: [65, 85, 92, 88, 90],&apos;Math&apos;: [30, 98, 96, 77, 90]&#125;df2 = DataFrame(data, index=[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;ZhaoYun&apos;, &apos;HuangZhong&apos;, &apos;DianWei&apos;], columns=[&apos;English&apos;, &apos;Math&apos;, &apos;Chinese&apos;]) 去除不必要的行或列1df2 = df2.drop(columns=[&apos;Chinese&apos;]) 重命名columns，让列名更容易识别1df2.rename(columns=&#123;&apos;Chinese&apos;: &apos;YuWen&apos;, &apos;English&apos;: &apos;Yingyu&apos;&#125;, inplace = True) 去除重复值1df = df.drop_duplicates() # 去除重复行 格式问题修改数据格式12df2[&apos;Chinese&apos;] = df2[&apos;Chinese&apos;].astype(&apos;str&apos;) df2[&apos;Chinese&apos;] = df2[&apos;Chinese&apos;].astype(np.int64) 数据间的空格123456# 删除左右两边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.strip)# 删除左边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.lstrip)# 删除右边空格df2[&apos;Chinese&apos;]=df2[&apos;Chinese&apos;].map(str.rstrip) 大小写转换123456# 全部大写df2.columns = df2.columns.str.upper()# 全部小写df2.columns = df2.columns.str.lower()# 首字母大写df2.columns = df2.columns.str.title() 查找空值1234# 查看那个地方存在空值df.isnull()# 查看哪列存在空值df.isnull().any() apply()目前未用到 数据统计Pandas 和 NumPy 一样，都有常用的统计函数，如果遇到空值 NaN，会自动排除。常见统计函数： 函数 作用 count() 统计个数，空值、NaN不计算 describe() 一次性输出多个统计指标，包括：count、mean、std、min、max等 min() 最小值 max() 最大值 sum() 总和 mean() 平均值 median() 中位数 var() 方差 std() 标准差 argmin() 统计最小值的索引位置 argmax() 统计最大值的索引位置 idxmin() 统计最小值的索引值 idxmax() 统计最大值的索引值 数据表合并12df1 = DataFrame(&#123;&apos;name&apos;:[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;data1&apos;:range(5)&#125;)df2 = DataFrame(&#123;&apos;name&apos;:[&apos;ZhangFei&apos;, &apos;GuanYu&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;], &apos;data2&apos;:range(5)&#125;) 指定列连接1df3 = pd.merge(df1, df2, on=&apos;name&apos;) 内连接merge的默认合并情况。1df3 = pd.merge(df1, df2, how=&apos;inner&apos;) 左连接1df3 = pd.merge(df1, df2, how=&apos;left&apos;) 右连接1df3 = pd.merge(df1, df2, how=&apos;right&apos;) 外连接1df3 = pd.merge(df1, df2, how=&apos;outer&apos;)","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://mrleecn.cn/tags/Pandas/"},{"name":"数据处理","slug":"数据处理","permalink":"https://mrleecn.cn/tags/数据处理/"}]},{"title":"验证码高效切片方法（Python）","date":"2019-05-21T11:46:14.000Z","path":"2019/05/21/image-split/","text":"说明验证码图片如下图所示： 验证码 切片完成后的效果如下图所示： 切片1 切片2 切片3 切片4 切片5 一、思路首先对图片进行预处理，请参考我的另一篇文章。然后再对验证码进行切片，切片包括： 纵向切片（去除字符左右的空白区域） 横向切片（去除字符上下的空白区域） 纵向切片从验证码图片的左端开始，依次遍历每列，寻找第一个含有黑像素的列，作为该字符切片的起始端。然后继续遍历，找到第一个不含黑像素的列，作为该字符切片的结束端（躺平的i、j只要尾部不要首部）。直到遍历完整张图片，即找到全部字符的切片位置，然后对图片进行切片，将每个字符切片保存为单独的图片。时间复杂度为O(n). 横向切片采用递归的方式。从图片中间的一行开始遍历。如果中间一行有黑色像素，表示中间一行在字符中间。由中间向两边遍历，找到字符的起始端start和结束端end。如果中间一行没有黑像素，于是分别在图片的上、下半部分继续采用递归的方式继续寻找。直到找到字符的两端（如果整张图片全为白色，则递归跳出的判断语句为start&gt;=end），然后进行切片，实现最终效果。时间复杂度为O(logn)。 二、代码实现1、纵向切片12345678910111213141516171819def deal_col(self, img_path): ''' 验证码纵向处理 :param img_path:验证码路径 :return: ''' image = Image.open(img_path) # 纵向切 letters = self.split_col(image) # 保存各个切片图片 try: for j in range(len(letters)): im_spilt = image.crop((letters[j][0], 0, letters[j][1], image.size[1])) new_path = self.img_dir + '&#123;0&#125;.gif'.format(j) im_spilt.save(new_path) self.captcha_firstsplit_paths.append(new_path) except: pass 1234567891011121314151617181920212223242526272829def split_col(self, image): ''' 寻找验证码纵向的切割边界 :param image: 验证码对象 :return: 每个字符的起始横坐标和结束横坐标的list ''' inletter = False # 标记当前列是否在字符内，False表示不在字符内，True表示在字符内 foundletter = False # 标记是否找到字符，False表示目前没找到字符，True表示已经找到字符 start = 0 end = image.size[0] letters = [] # 记录每个字符的起始坐标和结束坐标 for x in range(image.size[0]): # 按列查找 for y in range(image.size[1]): pix = image.getpixel((x, y)) if pix != 255: # 不为白色，表示进入字符 inletter = True if foundletter == False and inletter == True: # 刚进入字符，将foundletter标记为True foundletter = True start = x if foundletter == True and inletter == False: # 当前列已经出了字符，并将起始位置 foundletter = False # 将foundletter重置为False end = x if end - start &gt;= 4: # 如果字符切片宽度大于等于4像素，则记录起始终止位置； letters.append((start, end)) # 否则，认为当前切片为图片的噪点，或平躺的i、j首部（不具备唯一性，识别用不到，故剔除） inletter = False # 重置inletter为False # 最后一个字符贴边 if start != letters[-1][0]: # 如果当前的start和letters中最后一个start不等，后面还有字符，即字符贴边 letters.append((start, image.size[0])) # 最后一个字符的结束位置，即图片的宽度 return letters 2、横向切片12345678910111213141516def deal_row(self): ''' 单个字符横向处理 :return: ''' for captcha in self.captcha_firstsplit_paths: img = Image.open(captcha) # 横向切 top, botton = self.split_row(img, 0, img.size[1]-1) # 切割，并保存文件 try: im_spilt = img.crop((0, top, img.size[0], botton)) new_path = '&#123;0&#125;split__&#123;1&#125;'.format(self.img_dir, captcha.split('/')[-1]) im_spilt.save(new_path) except: pass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263def split_row(self, image, start, end): ''' 寻找验证码横向的切割边界 :param image: :return: ''' inletter = False # 表示当前在字符内部 if start &gt;= end: # 递归出口 return None, None mid = int((end - start) / 2) # 图片中间行 inletter = self.is_row_have_black(image, mid) # 中间一行出现黑像素表示进入字符中 if inletter == True: # 在字符中间 outletter_up = False # 是否出字符（上半部分），False表示没出字符，True表示已经出字符 outletter_down = False # 是否出字符（下半部分），False表示没出字符，True表示已经出字符 for i in range(1, int(mid) + 2): # 向两边发散，考虑到图片高度为偶数，从中间移动mid的距离不足以到达图片边界， # 特此将移动距离mid+2 # 向上 if outletter_up == False: row_have_black = self.is_row_have_black(image, mid - i) # 上i行是否有黑像素 if row_have_black is False: # 向上第一次全白的行 top = mid - i + 1 outletter_up = True # 已经出字符 if mid - i == 0: # 贴顶 top = 0 outletter_up = True # 向下 if outletter_down == False: row_have_black = self.is_row_have_black(image, mid + i) # 下i行是否有黑像素 if row_have_black is False: # 向下的第一行全白，下到底 botton = mid + i outletter_down = True if mid + i + 1 == image.size[1]: # 贴底 botton = mid + i + 1 outletter_down = True if outletter_up == True and outletter_down == True: if botton - top &gt;= 4: # 如果宽度大于等于4像素，返回top,botton return top, botton return None, None # 如果宽度小于4像素，返回None，None（即i、j的首部的点） # 不在字符中间，即字符位于上半部分或下半部分，或是i、j首位分离 else: top_up, botton_up = self.split_row(image, start, mid - 1) top_down, botton_down = self.split_row(image, mid + 1, end) if top_up != None and botton_up != None: # 字符在上半部分或i、j尾部在上半部分 return top_up, botton_up else: # 字符在上半部分或i、j头部在上半部分，尾部在下半部分 return top_down, botton_down pass 123456789101112def is_row_have_black(self, image, row): ''' 判断该行是否有黑像素 :param image: 图片对象 :param column: 图片的行 :return: ''' for i in range(image.size[0]): pix = image.getpixel((i, row)) # 获取图片某点的像素值 if pix != 1: # 不为白 return True return False","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://mrleecn.cn/tags/爬虫/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://mrleecn.cn/tags/验证码识别/"}]},{"title":"位运算技巧总结（python版）","date":"2019-05-19T01:44:54.000Z","path":"2019/05/19/位运算/","text":"1. 不用临时变量交换两个数异或运算 两个相同的数异或为0 即n ^ n = 0； 任何数与0异或为它本身，即n ^ 0 = n。 支持交换律、结合律 123a = a ^ b # （1）b = a ^ b # （2）a = a ^ b # （3） 解释如下： 把（1）中的 a 带入（2）中，则有 b = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a 同理将（1）、（2）的结果带入（3）中，则有 a = a ^ b = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b 2. 判断一个数的奇偶性与运算 相同为0，不同为1 判断一个数n是偶数还是奇数，只需要判断n的二进制最后一位是1还是0。是0表示是偶数，是1表示是奇数。 1if n &amp; 1 == 1: # n为奇数 3. 乘2/除212n &lt;&lt; 1 # 左移一位，表示乘2n &gt;&gt; 1 # 右移一位，表示除2 4. 取两个数中的最大值12def max(a, b): return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31) 解释如下： b &amp; ((a-b) &gt;&gt; 31)其中(a-b) &gt;&gt; 31 表示取(a-b)的符号位。 当b &lt;= a时，符号位为0，b &amp; 0 = 0 当b &gt; a时，符号位为-1。b &amp; -1 = b 即当b &gt; a时结果为b，否则结果为0。 a &amp; (~(a-b) &gt;&gt; 31)其中(~(a-b) &gt;&gt; 31) 表示对(a-b)的符号位取反。 当a &gt;= b时，取反结果为-1，a &amp; -1 = a 当a &lt; b时，取反结果为0，a &amp; 0 = 0 即当a &gt;= b时结果为a，否则结果为0。 最后对前两步结果进行或运算，因为前两步的结果中一定有一个为0，另一个非0（即最大值）。所以经过或运算后结果非0（即为最大值）。 5. 取两个数中的最小值12def max(a, b): return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31) 6. 取绝对值12def abs(n): return (n ^ (n &gt;&gt; 31) - (n &gt;&gt; 31)) 7. 找出只出现一次的数字 在一组整型数据中，只有一个数字出现了一次，其余数字都出现了两次。找出那个只出现一次的数字。 由异或运算的特性可知：两个相同数字进行异或结果为0；一个数和0异或结果为它本身；且异或支持交换律和结合律。所以只需要对全部的数字进行异或运算，结果就是只出现一次的数字。如l = [1,2,1,0,0] 1 ^ 2 ^ 1 ^ 0 ^ 0 = (1 ^ 1) ^ (0 ^ 0) ^ 2 = 0 ^ 0 ^ 2 = 2 1234567def find_only(l): tmp = l[0] for i in range(1, len(l)-1): tmp ^= l[i] return tmpl = [1,2,3,4,4,3,1,0,0]","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"},{"name":"编程技巧","slug":"编程技巧","permalink":"https://mrleecn.cn/tags/编程技巧/"}]},{"title":"Git使用（二）","date":"2019-05-17T01:10:50.000Z","path":"2019/05/17/git使用二/","text":"本笔记摘抄自Git教程，仅记录自己学习过程，侵删。 工作区与暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 git-repo 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 继续修改，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： git-stage 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 现在版本库变成了这样，暂存区就没有任何内容了： git-stage-after-commit 修改readme.txt。你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。有两种方法： 你可以手动删去最后一行 你可以使用git命令进行删除 撤销修改用git status查看一下： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) 你可以发现，Git会告诉你 git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 如果你还没使用git add把readme.txt文件添加到暂存区，那么可以使用git checkout -- file将工作区的修改全部撤销。 git reset HEAD &lt;file&gt;可以丢弃暂存区的修改 1234$ git reset HEAD readme.txtUnstaged changes after reset:M LICENSE.txtM readme.txt 如果你已经使用git add把readme.txt文件添加到暂存区，那么可以使用git reset HEAD &lt;file&gt;将暂存区的修改全部撤销。然后再使用git checkout -- file撤销工作区的修改。 删除文件添加一个新文件test.txt到Git并且提交： 123456$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 然后，手动删除工作区的test.txt文件。 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 这时候，出现两种情况： 情况1：文件删错了，要恢复文件1$ git checkout -- test.txt 现在，文件又在工作区出现了。 情况2：删的没错，清除版本库刚提交的test.txt方法一：使用git rm命令 1234567$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 方法二：使用git reset HEAD &lt;file&gt; 1$ git reset HEAD test.txt","tags":[{"name":"Git","slug":"Git","permalink":"https://mrleecn.cn/tags/Git/"}]},{"title":"time模块和datetime模块常见用法总结","date":"2019-05-16T07:41:50.000Z","path":"2019/05/16/time模块和datetime模块常见用法总结/","text":"time模块1import time 1. 获取当前时间123456&gt;&gt;&gt; localtime = time.localtime()&gt;&gt;&gt; localtime time.struct_time(tm_year=2019, tm_mon=4, tm_mday=25, tm_hour=16, tm_min=28, tm_sec=27, tm_wday=3, tm_yday=115, tm_isdst=0)# 2019年4月25日 16时28分27秒，本周的第3天（0是周一），本年的第115天，不是夏令时。&gt;&gt;&gt; type(localtime) # 时间元组类型&lt;class 'time.struct_time'&gt; 时间元组格式 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 一年中的第几天，1 到 366 8 tm_isdst 是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1 2. 分别获取当前年、月、日、今年第几天 等信息123456789&gt;&gt;&gt; year = localtime[0]&gt;&gt;&gt; month = localtime[1]&gt;&gt;&gt; day = localtime[2]&gt;&gt;&gt; year,month,day(2019, 4, 25)&gt;&gt;&gt; wday = localtime[6] # 本周第几天3&gt;&gt;&gt; yday = localtime[7] # 今年第几天115 3.获取当前时间戳123# 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数&gt;&gt;&gt; time.time() 1556182332.531831 4. 格式化时间（带时间戳）12&gt;&gt;&gt; localtime.strftime('%Y-%m-%d %H:%M:%S',x)'2019-04-25 16:28:27' python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 5. 推迟调用线程的运行1time.sleep(30) # 推迟30秒 datetime模块1. 获取当前时间123import datetime&gt;&gt;&gt; print(datetime.datetime.now())2019-04-25 17:11:02.275448 2.将时间戳转换成日期12&gt;&gt;&gt; print(datetime.date.fromtimestamp(1556182332.531831))2019-04-25 3.时间运算123456789101112# 当前时间+3天&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(+3)datetime.datetime(2019, 4, 28, 17, 14, 13, 969413)# 当前时间-3天&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(-3)datetime.datetime(2019, 4, 22, 17, 15, 11, 753718)# 当前时间+3小时&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(hours=3)datetime.datetime(2019, 4, 25, 20, 15, 42, 442473)# 当前时间+30分钟&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(minutes=30)datetime.datetime(2019, 4, 25, 17, 47, 2, 610058)","tags":[{"name":"Python","slug":"Python","permalink":"https://mrleecn.cn/tags/Python/"}]},{"title":"Git使用（一）","date":"2019-05-15T13:06:50.000Z","path":"2019/05/15/git使用一/","text":"本笔记摘抄自Git教程，仅记录自己学习过程，侵删。 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 创建一个版本库创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit pwd命令用于显示当前目录。 初始化第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 现在我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步： 用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步：用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 修改readme.txt文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 查看仓库当前状态运行git status命令看看结果： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 查看某个文件修改情况虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 1$ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： 123$ git commit -m &quot;add distributed&quot;[master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： 123$ git statusOn branch masternothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 查看历史修改在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线 版本回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 123456789┌────┐│HEAD│└────┘ │ └──&gt; ○ append GPL │ ○ add distributed │ ○ wrote a readme file 改为指向add distributed： 123456789┌────┐│HEAD│└────┘ │ │ ○ append GPL │ │ └──&gt; ○ add distributed │ ○ wrote a readme file 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 查看历史命令现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。","tags":[{"name":"Git","slug":"Git","permalink":"https://mrleecn.cn/tags/Git/"}]},{"title":"【转载】写给年轻程序员的10点启示","date":"2019-05-14T12:24:47.000Z","path":"2019/05/14/写给年轻程序员的10点启示/","text":"1转载自：https://segmentfault.com/a/1190000013972995， 侵删 写给年轻程序员的10点启示1. 正确认识自己相比码农、程序猿、软件工程师、张江男、屌丝程序员等等这些网络词汇，当你把自己看作是一个屌丝程序员的话，那你也可能就是那个衣食不愁，但整天浑浑噩噩、无所追求的屌丝。我更愿意用技匠这个词来形容程序员，就像我给自己起的花名一样。程序员应该是那些不断追求更高技术，并有着自己产品梦的工匠。当你通过对自己技术不断打磨，一次又一次做出那些优秀产品的时候，你会发现自己不再是他人口中的码农或是屌丝，而更多被称为了大师、大神，而受到大家的尊重。 2. 比一般人更加努力优秀的程序员往往会被同天才或高智商的人联系在一起，但我想告诉你，你周围所看到的那些天才（身边的优秀程序员）只是在你没看到的时候花了更多时间工作或者学习而已，当你也坚持这么做时，你也会变得和他们一样优秀。 3. 适时建立个人权威建立个人权威，这能让其他人看到你的不同之处，并为你在公司或团队内部构建起良好的影响力。当然，这一切的前提是你通过不断努力积累了自己的实力，并在恰当的时候去展现它。 4. 遵循最佳实践技术更新太快，作为程序员，如何才能适应这种变化呢？其实，就像每年都会有新的流行设计趋势，然而设计的本质和原则却始终不变一样。这些最佳实践或由此衍生出来的框架、工具都是那些富有经验的程序员通过大量实践，总结出来的最优秀的软件开发思想。通过理解和对它们的有效实践，能够让你站到前人的肩膀之上，对软件开发本身获得更深入的理解和认识。 5. 保持好奇心并乐于探索新的事物优秀的程序员们也往往非常乐于探索那些看似与工作无关的技术。比如，做后端的程序员去学习前端的技能，前端工程师则去学习UI设计，等等，这些虽不会让他们成为那一个领域的专家，但技术往往是相通的，当你在探索这些新鲜事物的同时，你会发现你原有的技能也得到了提升。 6. 抛开代码与人沟通“紧盯着电脑屏幕，不断敲击键盘，目光有些呆滞。”这可能是程序员给人的印象。而我所看到的那些优秀的程序员却都不是这样的，他们往往兴趣广泛，并且都乐于与人沟通交流。程序员们很容易会忽视与人的沟通，这其实对他们的职业生涯发展是不利的。我很支持那些年轻的程序员们坚持去走技术路线，但这不应该成为你排斥与人沟通的理由。你需要与人沟通来获得他人的帮助；你需要与人沟通来建立良好的工作关系；当你的能力不断提升，被赋予更多职责时，你更需要与人沟通来管理好自己的团队，以及与老板或客户进行有效的沟通等。 7. 要为优秀的人工作环境对一个人的影响是巨大的，而最可怕的是当你身处其中时，很难意识到你正在变得越来越糟。我之前带过一些不错的程序员，他们中的一些人去了一些整体氛围或环境不是太好的公司。过了一段时间后，再次与他们碰面聊天时，我发现他们的思维、观点相较之前并没有提升，有些甚至反而退步了。 8. 生活、睡眠、旅行我希望每个程序员都能明白工作、技术、写代码这些并不是你存在的意义，而生活才是，你需要懂得生活，并且学会生活。 生活：尝试有节制和有规律的生活，程序员生涯绝不是一次冲刺，而更像一场马拉松。 睡眠：很多人觉得睡眠是弱者的表现，他们往往会长时间熬夜，其实我觉得这是这一种恶性循环，反而会使你的工作效率变的更低。 旅行：去任何一个新的地方都可以称之为旅行，让你发现和感受新的东西，而这些是从电脑屏幕上无法获得的。 9. 相信自己的天赋和创造力每个人的身上都有属于他自己的天赋和创造力，但它们也绝不是与生俱来的，你需要在生活中不断地培养和发掘它们。下面是我觉得一些行之有效的方法。 阅读优秀的书籍：好的想法绝不是凭空产生的，尝试从书中寻找那些能激发你创意和灵感的优秀内容。 记录和收集：尝试用一个小本子，将你转瞬即逝的好想法记录下来，它们可能并不直接有效，但下一个更好的想法可能就是从这些你记录下来的想法中产生的。 尝试动手：光有好的想法是不够的，你需要成为一个有工匠精神的人，通过亲自动手去尝试和实践，你会不断从中得到新的创造力。 10. 如果上面提到的其他建议都对你无效，那么就请坚持第2点吧，因为它将成为你最大的竞争优势。那些程序员们后知后觉的职涯经验1. 你的薪酬与工作量无关换句话说你是否容易被取代。公司很容易找到一个和你差不多的应届毕业生，而那些对公司产品非常熟悉，并且起到关键作用的老员工，要想替代他们，公司所需要付出的代价及需要承担的风险就会高得多。所以，不妨摆正心态，正确认识到自己在公司中的位置，努力修炼内功，让自己变得越来越重要，相信你的薪资也会随之提升的。 2. 尽可能持续做一件事既然你对于公司的价值来自于你的不可替代性，那又该如何有效提升它呢？我的建议是尽可能持续做一件事。这既是指技术上的积累，也是指你能完整或较长时间参与同一个项目或开发一个产品。 技术深度及完整项目经验的重要性，如果你总是在跟随那些新出现的技术和框架，那你很难在某一项技术上达到理想的深度；同样，在一个公司里，如果你总是在更换项目，那你也很难提升自己的价值。参与10个项目，不如完整参与一个项目。持续做一件事是要你把每一件事做透、做好，而不是蜻蜓点水，浅尝辄止。 3. 唯一不变的就是变化本身作为程序员，我们又应该如何应对这些变化呢？我想说，你很难去改变所处的环境，或是阻挡那些变化的大趋势。你所能做的恰恰是培养自己持续学习的能力。 4. 你的声誉非常重要除了那些经常挂在嘴边的诚实守信、踏实肯干等之外，有一点特别重要，那便是严谨。因为它往往是判断一名程序员是否具备优秀潜质的重要因素。严谨的程序员对于分配给自己的任务会认真理解，对于自己的产出会仔细检查，这些都能大大减少工作中的出错概率，给团队或公司中的其他人留下良好的印象。 5. 理解沟通的意义当我们没有对问题有深入理解的时候，我们很难写出正确的程序来，因此我们需要向用户虚心求教，去真正理解他们所希望解决的问题。 6. 你的右脑将是你成功的关键谈到那些我们眼中非常成功的技术大牛、IT高管，都会出人意料地将一些非技术能力作为自己获得成功的关键。比如，编写文档或做PPT的能力、演讲的能力、说服他人的能力，等等。我虽然并不完全赞同最优秀的程序员不写代码这种观点，但我确信你的右脑将会是决定你能否成功的关键。 7. 不要轻易说简单和不可能年轻程序员们不应该轻易做出那些过于绝对的判断，应尽可能去使用科学的方法进行分析和论证，然后用不易被人误解的方式进行有效的表达，这样你提出的观点才能让大家感到信服。 8. 你不应该总是单打独斗如果你真的希望做出一些具有影响力的东西，那么光靠个人是很难实现的。你需要和团队中不同角色的人进行合作，有时候你需要说服别人，有时候你则会被别人说服。 9. 让你的能力显而易见那些优秀的程序员无时无刻不在体现他们的能力，从轻松地解决技术难题，到会议上提出被一致认可的解决方案，以及他们写出的那些优雅且完善的代码，这些都让他们显得与众不同，仿佛是天生的优秀程序员。但我想说，他们其实都是那些努力并使用了正确方法的人。程序员的能力来自于大量的编码实践，以及持续学习的能力和勤于思考的习惯。任何自作聪明，不懂装懂，以及投机取巧在明眼人看来都只会是东施效颦，显得如此微不足道。 每个程序员都应该了解的一件事我曾经接触过一些IT高管及行业的技术大牛，当私下聊起他们是如何变得如此出类拔萃时，他们大多会以自嘲但又略带得意的语气来讲述他们的那些独门秘籍。 我的文档写得特别好。 我的口才很好，总是能成功说服别人。 我的PPT做得非常棒，是公司里数一数二的。 我写过几篇很受欢迎的技术文章。 我热爱开源文化，并在社区里很有名气。 …… 我发现，这些普通人眼中的大神们很少会提及自己的技术有多牛，反而更多地把功劳归于那些看似与技术毫无关系的能力。大家千万别误以为他们只是一群华而不实，靠着一些小伎俩往上爬的小人。完全不是，而且我敢向你保证，他们中的每一个人在担任程序员或负责其他技术工作时，同样都有着非常出色的技术能力和优秀的工作表现。但为什么在他们眼中这些还不足以使他们达到现在的高度，反而是那些不起眼的写文档、做PPT、演讲等这些技能使他们能够在一次次竞争中胜出，并成为了我们中的佼佼者呢？ 其实在我看来，他们所谓的这些秘籍，都可以归纳为一种能力，那就是自我营销。 一名程序员如果能够尽早意识到自我营销的重要性，并有意识地锻炼和运用这种能力，那将对你的事业产生有益的帮助。 那么对于程序员们来说，又有哪些能够提升自我营销能力的方法呢？下面便是我的一些建议。 1. 读与技术无关的书我建议只买一些经典的技术书籍来帮你打基础，然后从网上去学习一切新的东西。我尤其鼓励大家去读那些与技术无关的书籍。程序员不善于自我营销，其中一个重要原因是他们自身所掌握的知识体系太过于单一，很难跳出技术范畴与人交流，并引起别人的兴趣和认同。你可以读任何历史、经济、人文、艺术类的书籍，它们都能够帮助你丰富自己的知识和思想，使你变得更加全面和完善，而这反过来，又能帮助你建立信心。 2. 会写文档文档可能是你完成代码编写后一个最佳的展示机会。当代码实现了它的功能之后，就很少有人会再去看它，除非它出错了。但文档被阅读的概率却大得多。从一个文档中，我们可以看到关于作者的很多东西，思路是否缜密，逻辑性是否强，设计方案是否优秀，等等。可以说，文档质量的高低是衡量一名程序员是否优秀的重要标准之一。 3. 学会包装说到包装，人们往往会产生一种不好的感觉，把它与虚伪、假的东西联系在一起。其实，我所说的包装应该包含两层意思： 知道什么是美的（优秀的）。 精心制作。 作者举例一个普华永道的高级经理通过一个长达114页的非常精美的PPT而赢得了保监会关于偿付能力改革的会议。 在日常工作中，我经常发现身边的程序员很难写出美观整洁的文档或PPT来。这一方面与我们从小缺乏美学教育有关，而更重要的往往是他们并没有真正用心去制作它。其实，我们可以通过寻找一些优秀的文档示例来学习如何制作优秀的文档，这其实并不困难。知道什么是优秀的，然后像写你的代码一样用心去制作就行了。 4. 尝试多讲讲话一直是很多程序员的硬伤，当然这也曾是我的硬伤。根据我的经验，你需要跨过以下两个障碍： 敢说。 让说的和你想的一致。 5.建立社会化联系一个完全封闭的程序员一定不是一个优秀的程序员。优秀的程序员往往愿意并善于与他人交流，分享自己的经验和想法，并在交流中获得有益的东西。这样做有很多好处： 通过这些社会化的活动能够使你的想法和技能更加完善。 能够使你建立权威，你的技术博客，在一些社区上的技术问题解答，以及你的开源项目等都会使人认为你是这方面的专家。 同样，你也可以获得他人的帮助，来解决棘手的难题。 你可以找到与你有相同兴趣的人，一起做有趣的事情。 你的社交网络将因此扩大，这意味着你所获得的机会将会更多。 程序员的烦恼1. 是否还应该留在一线城市一切都能为你的生活赋予意义，并让你感到更加快乐的话，那你还是应该更坚定地留下，而非选择离开。 2. 小公司做的事情太繁杂了时常会说“杂事不杂”，虽然看着被很多与技术无关的事务缠身，但它们对你来说同样具有意义。你从中可能获得沟通能力、管理能力、建立更广的人脉，在企业内部建立影响力，等等 3. 创业公司中的危机感无论成功与否，经历一次完整的创业都将让你受益匪浅。你将学到很多在大公司仅仅做一颗螺丝钉所学不到的东西。虽然在此过程中，你一定会有挫败感、焦虑，但或许坚持一下就会看到曙光。 另外一点我想说的是，创业的过程将让你获得不同的眼光。创业大多是在一个新的领域中进行的，你不应仅仅专注于公司所使用的那些技术，而更需要通过深入理解这个新的领域，去获得不同的视角和眼光，因为它们也会在未来成为你的核心竞争力。 4. 技术单一，想学习更多我总是很鼓励身边的程序员们去涉猎不同的技术甚至领域，但前提是你必须首先对某一门技术做到精通。技术是需要深耕的，深入学习一门主流的开发技术，并不断提升编程思维，比对很多技术栈都浅尝辄止要好很多。因此，如果精力有限不妨先学好一门技术，你会发现之后再去学习其他技术会变得容易许多，因为它们之间往往都是相通的。 5. 我想自学编程，应该学哪一门语言？如果你真的没有任何思路，只是希望你学的这门编程语言能够有用，我的建议是JavaScript，因为它看起来是唯一可能在未来所有领域内得到应用的编程语言，从我们的移动设备，到传统的Web应用，再到服务器端开发甚至是硬件编程，它几乎无处不在。 6. 大专学历，能进大公司吗？全日制本科几乎成了所有内部职位的最低要求，所以学历上的缺失确实会成为你进入大公司的障碍。当然还是有例外的情况： 通过内部员工的推荐。 通过外包公司进入后，再转为内部员工。 努力成为某一领域的专家，或者建立个人影响力。 如果你还是一名大专在读学生，那么我希望你不要过早焦虑，尝试问问自己除了学历之外还有什么让你能够脱颖而出的东西？是否有自己的个人项目？是否为知名的开源项目贡献过代码，甚至只是参与编写文档？是否通过写博客阐述过自己的独到观点，并得到大家的认可？在哪家公司实习过？这些都可能抓住雇主的眼球，从而弥补你在学历上的不足。 给年轻程序员的职涯建议1.尽早确定你想做的事情。尽早确定自己想做的事情——你的职业目标，意味着你可以获得比其他人更多的时间去努力。2.一万小时定律3.提高工作效率。有以下两点建议： 加快工作节奏 借助工具完成工作 4.简明的沟通方式5.持续学习6.学会控制情绪7.让最优秀的人围绕在你身边8.善于归纳与表达9.掌握英语10.睡眠是你更强大","tags":[{"name":"转载","slug":"转载","permalink":"https://mrleecn.cn/tags/转载/"},{"name":"职场","slug":"职场","permalink":"https://mrleecn.cn/tags/职场/"}]},{"title":"时间是怎么浪费掉的","date":"2019-05-13T14:06:50.000Z","path":"2019/05/13/时间是怎么浪费掉的/","text":"时间杀手最大的时间杀手–看电视危害2012年，尼尔森一份报告指出，两岁以上的美国人平均每周看电视直播的时间超过了34小时。这还不包括看录播节目。每周大概会花费40个小时看电视。 看电视不仅浪费时间，还会以你察觉不到的方式影响你的认知。电视节目把所有的问题都“短路”了， 让你不经过自己的大脑的任何思考就把一切都安排好。从消费习惯到世界观，均受电视直接影响。电视看的越多，你越会放弃对自己思想和行为的控制。 戒掉电视的方法一下戒掉看电视有些难，但我们可以通过一些方法一点一点逐步戒掉电视。 跟踪自己看电视的时长，想想自己都看那些节目，每周看多久。 不看直播。 合理规划自己看电视的时间，并严格控制自己不超时。长期坚持，慢慢减少看电视的时间。 寻求其他事情来占用自己看电视时间。 常见的时间杀手及解决办法 社交媒体和新闻网站 采用批处理的方式，你可以在一天内集中一两次进行社交媒体活动或查看新闻网站。即使这样也绝不会错过任何有用的东西。 不必要的会议 不必要的会议不要去。可以通过邮件处理的会议，用邮件处理。 玩电子游戏 强制自己不要玩。","tags":[{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"}]},{"title":"十步学习法","date":"2019-04-28T13:24:35.000Z","path":"2019/04/28/十步学习法/","text":"十步学习法为了能够掌握一门技术，需要了解以下三个要点： 如何开始 ：要想开始学习，现在需要掌握哪些基础知识。 学科范围 ：我现在学的东西有多宏大？我应该怎么怎样做？在开始阶段，不需要了解每个细节，但是需要对该学科的大概轮廓有所了解。 基础知识 ：不止在开始阶段，要想使用一项特定的技术，需要了解基本的用户案例和最常见的问题，也需要知道字节学的哪20%能满足80%的日常应用。 十步学习法体系基本思想 对自己要学的内容有个基本了解-了解自己不知道什么足矣。 利用这些信息勾勒出学习的范围，以及学成后又会获得什么。 利用上述知识，寻找各类资源，帮助自己学习。 制定自己学习计划，列出需要学习的课程，筛选学习材料，只保留能帮助自己达成目标的内容。 具体内容 第一步：了解全局 在深入研究某个主题之前至少要对其有所了解。这样才能弄清自己到底要学什么，才能找到最好的学习方法。 第二步：确定范围 明确自己的学习范围。运用上一步中获得的信息，让自己的关注点落脚到更小也更可控的范围。抵制该学习主题下的不同子主题的诱惑，尽可能专注于自己的学习范围。 第三步：定义目标 形成一份简明清晰的陈述，勾勒出你勤奋学习后的成功图景。确保其中包括具体的成功标准，从而能充分评估自己是否达到了学习目标。 第四步：寻找资源 通过多种途径，尽可能多的收集与自己所选主题相关的资源，此时无需考虑这些资源的质量。 第五步：创建学习计划 将自己的学习路径看作是自己写书时的大纲，结合第四步寻找到的图书目录，制定自己的学习计划。 第六步：筛选资源 把第四步中收集到的资源全部浏览一遍，找出那些内容能够覆盖到你的学习计划，结合评论，找出品质最高的资源。 第七步：开始学习，浅尝辄止 广度优先，获取足够多的与所学主题相关的信息。从而能让你开始学习，并在下一步计划中动手操作。 第八步：动手操作，边学边玩 无需提前了解全部内容，首先要做的就是亲自操作和亲身体验，在实践中学习。 第九步：全面掌握，学以致用 有效利用自己选择的资料，通过阅读文字、观看视频、与人交流等方式，沉浸在学习资料中，对知识深度挖掘。并试着把自己正在学习的内容和最终目标相关联。 第十步：乐为人师，融会贯通 走出自己的舒适区，将自己学到的知识交给别人。在这一过程中查缺补漏，切实剖析并理解自己所学知识，将其内化到自己思想。","tags":[{"name":"软技能","slug":"软技能","permalink":"https://mrleecn.cn/tags/软技能/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://mrleecn.cn/tags/读书笔记/"}]}]